<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://gladiouszhang.github.io/atom.xml" rel="self"/>
  
  <link href="http://gladiouszhang.github.io/"/>
  <updated>2024-11-11T08:59:49.581Z</updated>
  <id>http://gladiouszhang.github.io/</id>
  
  <author>
    <name>张舒俞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>higher库在元（强化）学习中的使用</title>
    <link href="http://gladiouszhang.github.io/2024/11/11/higher%E5%BA%93%E5%9C%A8%E5%85%83%EF%BC%88%E5%BC%BA%E5%8C%96%EF%BC%89%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://gladiouszhang.github.io/2024/11/11/higher%E5%BA%93%E5%9C%A8%E5%85%83%EF%BC%88%E5%BC%BA%E5%8C%96%EF%BC%89%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-11-11T06:28:49.000Z</published>
    <updated>2024-11-11T08:59:49.581Z</updated>
    
    <content type="html"><![CDATA[<p><code>higher.innerloop_ctx</code>是<code>higher</code>库的上下文管理器，用于创建内部循环（inner loop）的上下文，内部循环通常用于元学习场景，其中在模型参数更新的内部循环中进行一些额外的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">higher.innerloop_ctx(model, opt, device=<span class="literal">None</span>, copy_initial_weights=<span class="literal">True</span>, override=<span class="literal">None</span>, track_higher_grads=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>第一个参数model是需要进行<strong>内部循环</strong>的模型，通常是你的元模型。这个内部循环只是作为临时更新，结束内部循环后更新元模型真正的参数。</p></li><li><p>第二个参数opt是优化器，这是你用来更新模型参数的优化器</p></li><li><p>第三个参数copy_initial_weights是一个布尔值，<code>copy_initial_weights=True</code> 的作用是在进入内部循环上下文时，<strong>仅仅在一开始</strong>将 <code>model</code> 的参数拷贝一份到 <code>fmodel</code> 中。而在上下文期间的内部循环中，<code>fmodel</code> 的参数会持续累积更新，而不会在每次循环前被重新初始化；当 <code>copy_initial_weights=False</code> 时，<code>higher.innerloop_ctx</code> 不会在创建 <code>fmodel</code> 时复制 <code>model</code> 的参数。相反，<code>fmodel</code> 将直接引用 <code>model</code> 的参数。这意味着在内部循环中对 <code>fmodel</code> 的任何更新都会直接影响到 <code>model</code> 的参数。</p></li><li><p>第四个参数override是一个字典，例如override&#x3D;{‘lr’:lr_tensor, “momentum’: momentum_tensor}，用于指定在内部循环期间覆盖元模型优化器（即第二个参数opt）的参数，即给内外进行一个隔离。</p></li><li><p>第五个参数track_higher_grads是一个布尔值，用于跟踪更高阶的梯度，如果是True，则内部循环中计算的梯度将被跟踪以支持高阶的梯度计算，这对于实现元学习算法（例如 MAML）是必要的，因为 MAML 需要计算“关于初始参数的梯度的梯度”。如果设置为False，则不会跟踪高阶梯度。</p><ul><li><blockquote><p>在 MAML 中，我们的目标是找到一组初始参数，使模型能在不同任务的内部循环中快速适应。为了实现这一点，MAML 的外部循环需要对内部循环的更新进行微分，计算出高阶梯度。这使得元模型能够逐步优化其初始参数，以便在未来任务上更快地适应。</p></blockquote></li></ul></li></ul><p>gpt给出了一个基于higer的强化学习示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> higher</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个简单的线性模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleModel, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.linear(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成模拟任务，每个任务都有一个不同的线性关系</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_task</span>():</span><br><span class="line">    <span class="comment"># 随机生成斜率和偏置</span></span><br><span class="line">    slope = torch.randn(<span class="number">1</span>)</span><br><span class="line">    intercept = torch.randn(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机生成5个训练样本</span></span><br><span class="line">    x_train = torch.rand(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">    y_train = slope * x_train + intercept</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机生成5个测试样本</span></span><br><span class="line">    x_test = torch.rand(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">    y_test = slope * x_test + intercept</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (x_train, y_train), (x_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MAML的核心参数</span></span><br><span class="line">meta_lr = <span class="number">0.001</span>  <span class="comment"># 外部循环学习率</span></span><br><span class="line">inner_lr = <span class="number">0.01</span>  <span class="comment"># 内部循环学习率</span></span><br><span class="line">inner_steps = <span class="number">1</span>  <span class="comment"># 每个任务的内部循环步数</span></span><br><span class="line">meta_batch_size = <span class="number">4</span>  <span class="comment"># 每次元更新的任务数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型和元学习优化器</span></span><br><span class="line">model = SimpleModel()</span><br><span class="line">meta_optimizer = optim.Adam(model.parameters(), lr=meta_lr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元学习训练过程</span></span><br><span class="line"><span class="keyword">for</span> meta_step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):  <span class="comment"># 总的元学习步骤数</span></span><br><span class="line">    meta_optimizer.zero_grad()</span><br><span class="line">    meta_loss = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每次从不同的任务中采样</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(meta_batch_size):</span><br><span class="line">        <span class="comment"># 生成任务的训练和测试数据</span></span><br><span class="line">        (x_train, y_train), (x_test, y_test) = generate_task()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用 higher.innerloop_ctx 创建内部循环上下文</span></span><br><span class="line">        <span class="keyword">with</span> higher.innerloop_ctx(model, opt=optim.SGD(model.parameters(), lr=inner_lr), copy_initial_weights=<span class="literal">True</span>) <span class="keyword">as</span> (fmodel, diffopt):</span><br><span class="line">            <span class="comment"># 内部循环更新：在任务训练数据上进行 inner_steps 次更新</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(inner_steps):</span><br><span class="line">                train_pred = fmodel(x_train)</span><br><span class="line">                train_loss = nn.functional.mse_loss(train_pred, y_train)</span><br><span class="line">                diffopt.step(train_loss)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算任务验证损失，用于外部循环的更新</span></span><br><span class="line">            test_pred = fmodel(x_test)</span><br><span class="line">            test_loss = nn.functional.mse_loss(test_pred, y_test)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 累加所有任务的验证损失</span></span><br><span class="line">            meta_loss += test_loss</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算每个任务的平均验证损失，并对元模型进行反向传播</span></span><br><span class="line">    meta_loss /= meta_batch_size</span><br><span class="line">    meta_loss.backward()</span><br><span class="line">    meta_optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> meta_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta Step <span class="subst">&#123;meta_step&#125;</span>, Meta Loss: <span class="subst">&#123;meta_loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Meta-learning finished!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我认为核心是：</p><ul><li>在外部定义一个元模型和优化器，定义元强化学习外循环的训练次数。<ul><li>再定义需要多少个不同的任务。<ul><li>对于每个不同的任务，再进行多次内循环。<ul><li>在内循环内部借助元模型和优化器（可以覆盖部分参数）进行多轮训练。</li><li>每轮训练结束后进行参数更新</li></ul></li><li>内循环结束后在验证集上进行验证，得到loss</li><li>累计所有的loss</li></ul></li><li>对元模型使用平均后的loss进行更新</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;higher.innerloop_ctx&lt;/code&gt;是&lt;code&gt;higher&lt;/code&gt;库的上下文管理器，用于创建内部循环（inner loop）的上下文，内部循环通常用于元学习场景，其中在模型参数更新的内部循环中进行一些额外的操作。&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>阅读MapReduce</title>
    <link href="http://gladiouszhang.github.io/2024/11/07/%E9%98%85%E8%AF%BBMapReduce/"/>
    <id>http://gladiouszhang.github.io/2024/11/07/%E9%98%85%E8%AF%BBMapReduce/</id>
    <published>2024-11-07T14:49:34.000Z</published>
    <updated>2024-11-13T15:11:02.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>map：用来处理键值对来生成一组中间键值对</p><p>reduce：合并同一相同中间键相关联的中间值</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用途举例：倒排索引、web文档的图形化表示等。</p><p>操作简单，但是数据量大，需要多台机器并行计算。</p><p>问题：如何并行化计算、分发数据、处理故障</p><p>使用用户指定的map和reduce操作，用重新执行作为容错的机制</p><h1 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h1><p>map函数：由用户编写，输入一个对，然后输出一组中间键值对。MapReduce库会把所有具有相同key的中间键值对组合起来，然后发给Reduce函数处理。</p><p>reduce函数：也是由用户编写。接受中间键 I 和该键的一组值。它将这些值合并在一起以形成可能数量更小的一组值。通常reduce操作只产生0或1个值。中间值通过迭代器提供给用户的 Reduce 函数。这使我们能够处理太大而无法放入内存的值列表。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>统计单词词频：</p><p>map把所有的单词作为key，value分别设为1</p><p>reduce把相同key的value相加，输出结果</p><p>用户编写具体的代码实现填充到mapreduce specification对象中，然后把用户的代码和MapReduce库链接在一起实现。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><code>map</code> 和 <code>reduce</code> 函数的输入和输出类型在概念上是不同的，但在 C++ 实现中，通过字符串来统一传递数据。</p><p>用户需要在代码中处理字符串和实际数据类型之间的转换。</p><h2 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h2><h3 id="分布式grep（查找某个单词）"><a href="#分布式grep（查找某个单词）" class="headerlink" title="分布式grep（查找某个单词）"></a>分布式grep（查找某个单词）</h3><p>如果某一行满足提供的范式，map函数就把它发出。reduce只是把它拷贝一遍。</p><h3 id="URL访问频次统计"><a href="#URL访问频次统计" class="headerlink" title="URL访问频次统计"></a>URL访问频次统计</h3><p>map函数统计网站请求日志，并输出为&lt;url,1&gt;，reduce把后面的数值加起来</p><h3 id="反向web连接图"><a href="#反向web连接图" class="headerlink" title="反向web连接图"></a>反向web连接图</h3><p>在resource界面找到的target的url，经过map函数，输出&lt;target，resource&gt;对。reduce把resource整理成list，输出&lt;target,list(resource)&gt;</p><h3 id="每个主机的词向量"><a href="#每个主机的词向量" class="headerlink" title="每个主机的词向量"></a>每个主机的词向量</h3><p>词向量总结了一个或多个文件中最重要的单词的出现频率，是由&lt;word,frequency&gt;组成的列表。map从输入文件中读入hostname，输出&lt;hostname,term vector&gt;。reduce函数将每一个hostname的term vector合并并输出。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>就是说找到单词的位置。map输出&lt;word, 文件id&gt;，reduce把文件id合成一个list</p><h3 id="分布式排序"><a href="#分布式排序" class="headerlink" title="分布式排序"></a>分布式排序</h3><p>map函数从每一个记录中提取出key，输出&lt;key,record&gt;对，reduce啥也不变。排序取决于后面提到的分区工具和排序属性（稍后来填坑）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>MapReduce接口有许多不同的实现。正确的选择取决于环境。这节描述了一个针对Google广泛使用的计算环境的实现:用交换式以太网连接在一起的大型商用PC集群。</p><h2 id="执行概述"><a href="#执行概述" class="headerlink" title="执行概述"></a>执行概述</h2><p>通过将输入数据<strong>自动划分</strong>为一组M个部分，map函数调用分布在多台机器上。输入拆分可以由不同的机器并行处理。通过使用分区函数(例如，hash(key) mod R)将中间密钥空间划分成R个部分，来分布Reduce调用。分区数量(R)和分区函数由用户指定。</p><p><img src="/2024/11/07/%E9%98%85%E8%AF%BBMapReduce/image-20241111230234068.png" alt="image-20241111230234068"></p><ol><li><p>MapReduce库首先将输入文件分成M段，每段通常16MB-64MB，然后在集群的机器上开启程序的许多副本（图中fork成worker和master）。</p></li><li><p>其中有一个特殊的副本叫master，其他的都是被master分配工作的worker。有M个映射任务和R个归约任务要分配。master挑选空闲的worker来分配一个map任务或者一个reduce任务</p></li><li><p>被分配了map的worker读取相应输入分割的内容。它从输入数据中解析出键&#x2F;值对，并将每一对传递给用户定义的reduce函数。Map函数产生的中间键&#x2F;值对在内存中缓冲。</p></li><li><p>缓存的pair被周期性的写到本地磁盘。由分区函数（前面提到的hash取余）划分成R个区域。这些缓冲对在本地磁盘上的位置被传递回master，主设备负责将这些位置转发给reduce工作器。</p></li><li><p>当mater通知reduce worker这些位置时，它使用rpc从map workers的本地磁盘读取缓冲数据。当reduce worker读取了所有的中间数据后，它会按照中间键对数据进行排序，以便将所有出现的相同键组合在一起。需要进行排序是因为通常许多不同的键映射到同一个reduce任务，为了确保<strong>相同的键的所有值被分组在一起</strong>，这有助于 <strong>Reduce</strong> 阶段对这些键进行集中处理。如果中间数据量太大，不适合内存，就使用<strong>外部排序（？）</strong>。</p><blockquote><p>如果中间数据量非常大，无法完全放入内存中进行排序，这时候就需要使用<strong>外部排序（External Sort）</strong>。<strong>外部排序</strong> 是一种用于处理超大规模数据的排序方法，因为这些数据太大而无法一次性加载到内存中。外部排序的典型做法是将数据分块处理，将每个块单独排序后写回磁盘，最后将所有已排序的块合并起来，形成一个最终有序的数据集。在这个过程中，<strong>Reduce</strong> 节点会将无法容纳在内存中的数据分批次地进行排序和合并，直到所有数据都已经排序完成。这种排序策略对于处理超大规模数据非常有效。</p></blockquote></li><li><p>reduce worker在排好序的中间数据上遍历，对于遇到的每个中间键（唯一的，不会重复发！），它会把键和值都发给reduce函数。reduce函数的输出被附加到这个Reduce分区的最终输出文件中。</p></li><li><p>当所有的map任务和reduce任务完成后，主机唤醒用户程序。此时，用户程序中的MapReduce调用返回到用户代码</p></li></ol><p>最后用户得到R个输出文件，但是不一定会合并，因为会作为下一个输入（可能）</p><h2 id="Master的数据结构"><a href="#Master的数据结构" class="headerlink" title="Master的数据结构"></a>Master的数据结构</h2><p>master保存的数据结构：对于每个map和reduce任务，master保存其状态（空闲、进行中、完成）和非空闲状态任务的worker的身份。</p><p>master是用来讲map任务产生的中间文件传播到reduce任务的通道。所以master存着已完成的map任务的中间文件的位置和大小，如果有新的map任务完成会继续更新，并且用增量的方式推送到正在执行reduce任务的worker。</p><h2 id="错误容忍"><a href="#错误容忍" class="headerlink" title="错误容忍"></a>错误容忍</h2><h3 id="worker失效（failure）"><a href="#worker失效（failure）" class="headerlink" title="worker失效（failure）"></a>worker失效（failure）</h3><p>master间歇性ping worker。如果一段时间worker没回就是挂了。所有分到这个worker的map任务都会重新召回标记为空闲状态，进行重新调度。reduce也是类似的。就算是已完成的map任务，也会重新执行，因为他们的map中间结果在挂了的worker上。完成的reduce任务不需要重新执行，因为他们输出存储在全局文件系统中。</p><p>A挂了之后把map分给B时，所有的reduce worker都会收到这次A原本的工作执行的通知（因为不知道这个任务分给了哪个reduce worker，让所有人都知道要换个地方找）。</p><p>mapreduce能够容忍大规模的woker挂掉。</p><h3 id="master失效"><a href="#master失效" class="headerlink" title="master失效"></a>master失效</h3><p>主节点周期性的写master数据结构的checkpoints。master挂了的话就从最后一个checkpoint开启一个副本。但因为只有一个master，不太可能故障。所以如果master故障的话会终止mapreduce。如果需要，客户端可以检查并重试MapReduce操作。</p><blockquote><p>属于是技术上可以做但是没必要</p></blockquote><h3 id="在故障情况下的语义（？）"><a href="#在故障情况下的语义（？）" class="headerlink" title="在故障情况下的语义（？）"></a>在故障情况下的语义（？）</h3><blockquote><p>系统在出现<strong>故障</strong>时，计算程序所产生的<strong>行为和结果</strong>的定义。它探讨的是，系统中某些组件（比如某些节点或任务）如果出现故障，整个系统在处理任务时依然要保证的<strong>结果的正确性</strong>和<strong>一致性</strong>。</p></blockquote><p>当用户提供的 <strong>map</strong> 和 <strong>reduce</strong> 操作是输入值的确定性函数时，mapreduce会生成与不发生故障的顺序执行整个程序时相同的输出。（就是说故障情况下结果依然是一样的）。这是依赖于map和reduce任务输出的原子提交：每个进行中的任务都将其输出写入私有临时文件。reduce任务产生一个这样的文件，map任务产生R个这样的文件(每个reduce任务一个)。当map任务完成时，worker向master发送一条消息，并在消息中包含R个临时文件的名称。如果主服务器收到已完成的map任务的完成消息，它将忽略该消息（可能原来挂了的复活了）。否则，它在主数据结构中记录R文件的名称。</p><blockquote><ul><li><p>假设我们有两个 <strong>Reduce worker</strong>，分别是 <strong>A</strong> 和 <strong>B</strong>，同时存在一个 <strong>Reduce 任务 R</strong>。下面是详细的流程描述，包括一个 <strong>worker</strong> 挂掉的过程。</p><h4 id="1-初始分配任务"><a href="#1-初始分配任务" class="headerlink" title="1. 初始分配任务"></a>1. 初始分配任务</h4><ul><li>主节点将 <strong>Reduce 任务 R</strong> 分配给 <strong>worker A</strong> 执行。</li><li><strong>worker A</strong> 开始执行这个 <strong>Reduce 任务</strong>，并逐步处理数据，将结果写入到一个临时文件 <strong>tempA</strong> 中。</li></ul><h4 id="2-任务执行过程中发生故障"><a href="#2-任务执行过程中发生故障" class="headerlink" title="2. 任务执行过程中发生故障"></a>2. 任务执行过程中发生故障</h4><ul><li>假设 <strong>worker A</strong> 在执行过程中由于某种原因（例如硬件故障、网络断连等）突然<strong>挂掉</strong>，它无法完成任务。</li><li>主节点监控着所有任务的状态，发现 <strong>worker A</strong> 在规定的时间内没有汇报任务进度或完成情况，于是判断 <strong>worker A</strong> 失效。</li><li>主节点决定将 <strong>Reduce 任务 R</strong> 重新分配给另一个健康的 <strong>worker B</strong> 来执行。</li></ul><h4 id="3-新的任务分配给-worker-B"><a href="#3-新的任务分配给-worker-B" class="headerlink" title="3. 新的任务分配给 worker B"></a>3. 新的任务分配给 <strong>worker B</strong></h4><ul><li><strong>worker B</strong> 接到任务后，开始重新执行 <strong>Reduce 任务 R</strong>，它可能需要从中间数据中读取并计算，生成自己的临时文件 <strong>tempB</strong>。</li><li><strong>worker B</strong> 最终完成了任务，并生成了临时文件 <strong>tempB</strong>，准备将其重命名为最终的输出文件 <strong>final_output</strong>。</li></ul><h4 id="4-worker-A-恢复运行"><a href="#4-worker-A-恢复运行" class="headerlink" title="4. worker A 恢复运行"></a>4. <strong>worker A</strong> 恢复运行</h4><ul><li>在 <strong>worker B</strong> 正在执行任务时，之前挂掉的 <strong>worker A</strong> 突然<strong>恢复运行</strong>了。</li><li>恢复后的 <strong>worker A</strong> 会继续之前中断的工作，并试图完成它的 <strong>Reduce 任务</strong>。因此，<strong>worker A</strong> 最终也生成了它自己的临时文件 <strong>tempA</strong>。</li></ul><h4 id="5-两个-worker-竞争写入最终输出"><a href="#5-两个-worker-竞争写入最终输出" class="headerlink" title="5. 两个 worker 竞争写入最终输出"></a>5. 两个 <strong>worker</strong> 竞争写入最终输出</h4><ul><li>现在我们有两个不同的 <strong>worker</strong>（A 和 B），它们都认为自己完成了 <strong>Reduce 任务 R</strong>，并且分别生成了两个不同的临时文件 <strong>tempA</strong> 和 <strong>tempB</strong>。</li><li><strong>worker A</strong> 和 <strong>worker B</strong> 都会尝试将各自的临时文件重命名为最终的输出文件 <strong>final_output</strong>。</li></ul><h4 id="6-原子重命名操作的应用"><a href="#6-原子重命名操作的应用" class="headerlink" title="6. 原子重命名操作的应用"></a>6. 原子重命名操作的应用</h4><ul><li>在执行重命名时，底层文件系统的<strong>原子重命名操作</strong>起到了关键作用。</li><li>假设 <strong>worker B</strong> 先尝试重命名它的临时文件 <strong>tempB</strong> 为 <strong>final_output</strong>，由于<strong>重命名操作是原子的</strong>，<strong>worker B</strong> 成功地将 <strong>tempB</strong> 重命名为了 <strong>final_output</strong>。</li><li>由于文件系统的<strong>原子性</strong>，这个重命名操作是不可分割的，意味着此时最终的输出文件 <strong>final_output</strong> 已经确定下来，包含的是 <strong>worker B</strong> 的结果。</li><li>当 <strong>worker A</strong> 尝试重命名它的临时文件 <strong>tempA</strong> 为 <strong>final_output</strong> 时，发现这个名称已经存在，因此它的重命名操作会<strong>失败</strong>。</li><li>通过这种机制，最终的文件系统中<strong>只会保留一次任务的输出</strong>，并且最终的输出文件 <strong>final_output</strong> 中包含的是某一个 <strong>Reduce worker</strong> 成功执行后的数据（在这个例子中是 <strong>worker B</strong> 的数据）。</li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;map：用来处理键值对来生成一组中间键值对&lt;/p&gt;
&lt;p&gt;reduce：合并同一相同中间键相关联的中间值&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式系统" scheme="http://gladiouszhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>边缘计算中的移动管理（Mobility Management）</title>
    <link href="http://gladiouszhang.github.io/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/"/>
    <id>http://gladiouszhang.github.io/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/</id>
    <published>2024-08-20T17:03:28.000Z</published>
    <updated>2024-11-07T16:09:24.727Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">资源发现</a><ul><li><a href="#----">一些算法</a><ul><li><a href="#1-------------directory-based-resource-discovery---">1. <strong>基于目录的资源发现（Directory-Based Resource Discovery）</strong></a></li><li><a href="#2-------------agent-based-resource-discovery---">2. <strong>基于代理的资源发现（Agent-Based Resource Discovery）</strong></a></li><li><a href="#3-----p2p------peer-to-peer-resource-discovery---">3. <strong>基于P2P的资源发现（Peer-to-Peer Resource Discovery）</strong></a></li><li><a href="#4-------------broadcast-based-resource-discovery---">4. <strong>基于广播的资源发现（Broadcast-Based Resource Discovery）</strong></a></li><li><a href="#5-----ai-ml------ai-ml-based-resource-discovery---">5. <strong>基于AI&#x2F;ML的资源发现（AI&#x2F;ML-Based Resource Discovery）</strong></a></li><li><a href="#6-------------collaborative-resource-discovery---">6. <strong>基于协作的资源发现（Collaborative Resource Discovery）</strong></a></li><li><a href="#7---------------location-based-resource-discovery---">7. <strong>基于物理位置的资源发现（Location-Based Resource Discovery）</strong></a></li></ul></li><li><a href="#----">文献综述</a><ul><li><a href="#----------">不同类型的分布式系统</a><br>~ <a href="#----------">网格计算环境（稀疏）</a><br>~ <a href="#p2p---------">P2P计算系统（点对点）</a><br>~ <a href="#--------">集群计算（集中）</a></li><li><a href="#----">主要问题</a></li><li><a href="#-----">主要的方法</a></li></ul></li><li><a href="#-------">一些相关的论文</a><br>  ~ <a href="#----------------------------">一种在边缘网络中使用元数据复制进行资源发现的去中心化方法</a><br>- <a href="#----">问题背景</a></li></ul></li></ul><!-- tocstop --><h1 id="资源发现"><a href="#资源发现" class="headerlink" title="资源发现"></a>资源发现</h1><p>资源发现是指在边缘计算环境中，移动设备需要及时找到可用的计算资源（如边缘服务器或云服务器）来执行任务。这包括识别最接近且最适合的边缘节点，以及在动态网络环境中快速发现可用资源。这一过程涉及多个技术，如网络感知、位置感知和服务发现协议等。</p><h2 id="一些算法"><a href="#一些算法" class="headerlink" title="一些算法"></a>一些算法</h2><h3 id="1-基于目录的资源发现（Directory-Based-Resource-Discovery）"><a href="#1-基于目录的资源发现（Directory-Based-Resource-Discovery）" class="headerlink" title="1. 基于目录的资源发现（Directory-Based Resource Discovery）"></a>1. <strong>基于目录的资源发现（Directory-Based Resource Discovery）</strong></h3><ul><li>方法设计：<ul><li><strong>目录服务：</strong> 中央目录服务器或分布式目录服务用于维护所有边缘节点及其可用资源的索引。</li><li><strong>查询机制：</strong> 移动设备通过查询目录服务获取可用资源的列表。目录服务会根据资源的负载、网络延迟等条件返回最优资源。</li><li><strong>优点：</strong> 查询效率高，适合静态或半动态环境。</li><li><strong>挑战：</strong> 中央目录可能成为瓶颈，分布式目录需要复杂的同步机制。</li></ul></li></ul><h3 id="2-基于代理的资源发现（Agent-Based-Resource-Discovery）"><a href="#2-基于代理的资源发现（Agent-Based-Resource-Discovery）" class="headerlink" title="2. 基于代理的资源发现（Agent-Based Resource Discovery）"></a>2. <strong>基于代理的资源发现（Agent-Based Resource Discovery）</strong></h3><ul><li>方法设计：<ul><li><strong>智能代理：</strong> 部署在边缘节点或设备上的智能代理会主动发现并推荐资源。代理可以使用本地缓存、学习历史任务数据，以优化资源选择。</li><li><strong>分布式协调：</strong> 代理之间可以通过协商或竞标机制，共同决定资源的分配。协商机制可以基于效用函数或策略投标。</li><li><strong>优点：</strong> 自适应能力强，适应动态变化的网络环境。</li><li><strong>挑战：</strong> 代理间的通信开销和复杂性较高。</li></ul></li></ul><h3 id="3-基于P2P的资源发现（Peer-to-Peer-Resource-Discovery）"><a href="#3-基于P2P的资源发现（Peer-to-Peer-Resource-Discovery）" class="headerlink" title="3. 基于P2P的资源发现（Peer-to-Peer Resource Discovery）"></a>3. <strong>基于P2P的资源发现（Peer-to-Peer Resource Discovery）</strong></h3><ul><li>方法设计：<ul><li><strong>分布式哈希表（DHT）：</strong> 使用DHT来索引和检索资源，提供高效的查询路由。每个节点负责管理一部分资源索引。</li><li><strong>随机游走：</strong> 资源发现可以通过随机游走策略，让查询请求在网络中随机传播，直到找到合适的资源。</li><li><strong>优点：</strong> 高度分布式，适合大规模动态环境。</li><li><strong>挑战：</strong> 查询延迟可能较高，且可能出现查找失败的情况。</li></ul></li></ul><h3 id="4-基于广播的资源发现（Broadcast-Based-Resource-Discovery）"><a href="#4-基于广播的资源发现（Broadcast-Based-Resource-Discovery）" class="headerlink" title="4. 基于广播的资源发现（Broadcast-Based Resource Discovery）"></a>4. <strong>基于广播的资源发现（Broadcast-Based Resource Discovery）</strong></h3><ul><li>方法设计：<ul><li><strong>洪泛搜索：</strong> 移动设备可以广播资源请求给所有邻近节点，所有收到请求的节点都会响应。</li><li><strong>限制广播：</strong> 为减少网络流量，设计限次广播或逐层扩展广播（如时间生存值TTL）。</li><li><strong>优点：</strong> 简单直接，适合小规模网络。</li><li><strong>挑战：</strong> 网络开销大，容易造成广播风暴。</li></ul></li></ul><h3 id="5-基于AI-ML的资源发现（AI-ML-Based-Resource-Discovery）"><a href="#5-基于AI-ML的资源发现（AI-ML-Based-Resource-Discovery）" class="headerlink" title="5. 基于AI&#x2F;ML的资源发现（AI&#x2F;ML-Based Resource Discovery）"></a>5. <strong>基于AI&#x2F;ML的资源发现（AI&#x2F;ML-Based Resource Discovery）</strong></h3><ul><li>方法设计：<ul><li><strong>预测模型：</strong> 通过机器学习模型预测未来资源需求和可用性，智能调度资源分配。</li><li><strong>强化学习：</strong> 使用强化学习方法，设备和边缘节点可以不断学习和优化资源发现策略。</li><li><strong>优点：</strong> 动态性和自适应性强，能够应对复杂环境。</li><li><strong>挑战：</strong> 需要大量训练数据和计算资源，可能增加系统复杂性。</li></ul></li></ul><h3 id="6-基于协作的资源发现（Collaborative-Resource-Discovery）"><a href="#6-基于协作的资源发现（Collaborative-Resource-Discovery）" class="headerlink" title="6. 基于协作的资源发现（Collaborative Resource Discovery）"></a>6. <strong>基于协作的资源发现（Collaborative Resource Discovery）</strong></h3><ul><li>方法设计：<ul><li><strong>合作式资源分享：</strong> 多个边缘节点合作分享和发现资源，通过合作机制，如任务分发或资源借用，提高资源利用率。</li><li><strong>分布式调度：</strong> 协作式调度机制能够根据任务优先级、节点负载情况动态调整资源发现策略。</li><li><strong>优点：</strong> 提高资源利用效率，减少单点瓶颈。</li><li><strong>挑战：</strong> 协作机制的设计复杂，需要考虑公平性和资源共享的效率。</li></ul></li></ul><h3 id="7-基于物理位置的资源发现（Location-Based-Resource-Discovery）"><a href="#7-基于物理位置的资源发现（Location-Based-Resource-Discovery）" class="headerlink" title="7. 基于物理位置的资源发现（Location-Based Resource Discovery）"></a>7. <strong>基于物理位置的资源发现（Location-Based Resource Discovery）</strong></h3><ul><li>方法设计：<ul><li><strong>地理距离优化：</strong> 根据设备与边缘节点的物理距离优先选择最近的节点，以降低网络延迟。</li><li><strong>区域划分：</strong> 将区域划分为多个小区，每个小区内的资源通过区域内广播或P2P方式发现。</li><li><strong>优点：</strong> 提高服务质量（QoS），减少延迟。</li><li><strong>挑战：</strong> 需要精确的位置感知技术，并可能面临区域内资源不均衡的问题。</li></ul></li></ul><h2 id="文献综述"><a href="#文献综述" class="headerlink" title="文献综述"></a>文献综述</h2><blockquote><p>A. R. Khan, S. Imtiaz and A. H. Farooqi, “A Survey of the Resource Discovery Techniques in the Distributed Computing Systems,” 2022 International Conference on IT and Industrial Technologies (ICIT), Chiniot, Pakistan, 2022, pp. 1-6, doi: 10.1109&#x2F;ICIT56493.2022.9989068. keywords: {Computer architecture;Distributed computing;distributed computing;resource discovery;net-work structures},</p><p>分布式计算系统中的资源发现技术综述</p></blockquote><h3 id="不同类型的分布式系统"><a href="#不同类型的分布式系统" class="headerlink" title="不同类型的分布式系统"></a>不同类型的分布式系统</h3><h4 id="网格计算环境（稀疏）"><a href="#网格计算环境（稀疏）" class="headerlink" title="网格计算环境（稀疏）"></a>网格计算环境（稀疏）</h4><p>包含多个可用资源，这些资源通常位于偏远位置，这些资源在地理上作为一个单元工作。目标是为手头的工作发现最有效的资源。</p><blockquote><p>Javad Zarrin, Rui L Aguiar and João Paulo Barraca, “Resource discovery for distributed computing systems: A comprehensive survey”, <em>Journal of parallel and distributed computing</em>, vol. 113, pp. 127-166, 2018.</p></blockquote><h4 id="P2P计算系统（点对点）"><a href="#P2P计算系统（点对点）" class="headerlink" title="P2P计算系统（点对点）"></a>P2P计算系统（点对点）</h4><p>旨在通过允许对等方之间的资源共享来增强分布式环境的可扩展性。</p><blockquote><p>S Vimal and S Srivatsa, “A new cluster p2p file sharing system based on ipfs and block-chain technology”, <em>Journal of Ambient Intelligence and Humanized Computing</em>, pp. 1-7, 2019.</p></blockquote><h4 id="集群计算（集中）"><a href="#集群计算（集中）" class="headerlink" title="集群计算（集中）"></a>集群计算（集中）</h4><p>主要考虑调度问题，而不是资源发现。</p><blockquote><p>Huang Wenzhun, Wang Haoxiang, Zhang Yucheng and Zhang Shanwen, “A novel cluster computing technique based on signal clustering and analytic hierarchy model using hadoop”, <em>Cluster Computing</em>, vol. 22, pp. 13077-13084, 2019.</p></blockquote><h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><ul><li>可扩展性：随着计算资源的增长 ，发现算法必须保持其性能。</li><li>效率：最小化用户请求发现适当资源时的响应时间。</li><li>异构性：满足不同设备的需求。</li><li>可靠性：定期维护已发现的资源，以消除资源不一致。</li></ul><h3 id="主要的方法"><a href="#主要的方法" class="headerlink" title="主要的方法"></a>主要的方法</h3><ol><li><p>手动方法</p><p>手动方法依赖于用户手动输入资源请求并选择合适的资源。该方法通常通过模块化的方式处理请求，先接收用户的资源请求，然后按资源与请求的匹配度排序，最后根据访问成本对资源进行分组。虽然这种方法简单直接，但容易出现服务质量问题，因为优化的资源列表是在实时计算的</p><blockquote><p>Massimiliano Assante, Leonardo Candela, Donatella Castelli, Roberto Cirillo, Gianpaolo Coro, Luca Frosini, Lucio Lelii, Francesco Man-giacrapa, Valentina Marioli, Pasquale Pagano et al., “The gcube system: delivering virtual research environments as-a-service”, <em>Future Generation Computer Systems</em>, vol. 95, pp. 445-453, 2019.</p></blockquote></li><li><p>基于树的方法</p><p>基于树的方法使用决策树或其他树形结构来组织和管理资源。这些方法通过定期更新节点的属性值，并按优化的顺序存储资源信息，从而快速找到符合用户条件的资源。树结构的优势在于其查找效率（如O(log n)），但在数据不平衡的情况下可能导致查找效率降低</p><p><strong>感觉红黑树可以解决平衡问题，然后个人感觉这就是在手动方法上面加了一个存储的数据结构？</strong></p><blockquote><p>Mohammad Samadi Gharajeh, “A knowledge and intelligent-based strategy for resource discovery on iaas cloud systems”, <em>Int. J. Grid Util. Comput.</em>, vol. 12, no. 2, pp. 205-221, 2021.</p></blockquote></li><li><p>语义方法</p><p>语义方法利用语义网技术，通过构建领域特定的本体（Ontology）来实现资源发现。这些方法通过存储和管理节点的语义信息，来帮助找到相关领域的资源。然而，由于依赖领域知识，这些方法在可扩展性方面存在局限性</p><p>语义网技术是一种通过为信息赋予明确意义的技术，使机器能够理解和处理数据，而不仅仅是读取。它为数据提供了一个结构化的、标准化的表示形式，使得不同系统之间的数据可以相互理解和处理。</p><p>本体是在特定领域内定义的概念和关系的集合，简单来说，它为某一领域的概念提供了一种标准化的表达方式。例如，在医疗领域，“医生”、“病人”、“治疗”可能都是本体中的概念，而它们之间的关系则可以被清晰地定义出来。</p><p><img src="/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/895465e0-86a4-4592-be21-01858f0c225c-17245223368481.png" alt="img"></p><blockquote><p>Aolong Zhou, Kaijun Ren, Xiaoyong Li, Wen Zhang, Xiaoli Ren and Kefeng Deng, “Semantic-based discovery method for high-performance computing resources in cyber-physical systems”, <em>Microprocessors and Microsystems</em>, vol. 80, pp. 103328, 2021.</p></blockquote></li><li><p>基于对象的方法</p><p>基于对象的方法采用面向对象的方式来组织节点和资源信息。资源以对象的形式存储，并根据对象之间的关系进行管理。这种方法在管理大规模节点时具有优势，但由于维护每个对象的元信息的复杂性，可能会导致系统不稳定。</p></li><li><p>边缘计算方法</p><p>边缘计算方法适用于物联网（IoT）等分布式网络环境，重点在于在边缘设备上发现和管理资源。这种方法可以结合其他方法（如基于树或语义的方法）来优化资源发现，特别适合在性能和服务质量要求较高的场景中应用。</p></li></ol><blockquote><p>Gyeongmin Lee, Bongjun Kim, Seungbin Song, Seonyeong Heo and Hanjun Kim, “Comflex: Composable and flexible resource management for the iot”, <em>IEEE Internet of Things Journal</em>, vol. 8, no. 22, pp. 16406-16417, 2020.</p></blockquote><h2 id="一些相关的论文"><a href="#一些相关的论文" class="headerlink" title="一些相关的论文"></a>一些相关的论文</h2><h4 id="一种在边缘网络中使用元数据复制进行资源发现的去中心化方法"><a href="#一种在边缘网络中使用元数据复制进行资源发现的去中心化方法" class="headerlink" title="一种在边缘网络中使用元数据复制进行资源发现的去中心化方法"></a>一种在边缘网络中使用元数据复制进行资源发现的去中心化方法</h4><blockquote><p>I. Murturi and S. Dustdar, “A Decentralized Approach for Resource Discovery using Metadata Replication in Edge Networks,” in IEEE Transactions on Services Computing, vol. 15, no. 5, pp. 2526-2537, 1 Sept.-Oct. 2022, doi: 10.1109&#x2F;TSC.2021.3082305.</p></blockquote><h5 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h5><ul><li>忽视了任务与物联网资源之间的关联性（就是说分配的任务可能是该物联网设备不擅长的）</li><li>边缘设备和网络组织之间的通信被忽视（比如设备、边缘服务器、云服务器这些之间的通信或者网络拓扑结构）</li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>应指定<strong>边缘网络</strong>以去中心化和自动的方式处理发现资源的复杂性（架构上）<ul><li>以P2P的方式连接边缘设备。一组边缘设备组成一个<em>集群</em>（cluster）;而多个相连的集群组成一个边缘网络，分别<em>是一个边缘邻域</em>（edge neighborhood）。还存在相应的系统协调器，用于组织发现资源的过程。建立在 Kademlia 协议之上，作为边缘设备之间的通信协议。Kademlia 是用于去中心化 P2P 计算机网络的分布式哈希表 （DHT）。当边缘设备更新其本地 DHT 时，这些更改会传播到所有其他设备，从而允许再次查询和操作它们。同样，有关当前集群协调员和全局协调员的信息也存储在 DHT 中。协调器是动态放置的，并在提供各种服务的最合适的边缘设备上运行，动态评估。</li></ul></li><li>发现边缘段的可用资源（发现过程）<ul><li>以自动方式在边缘设备之间交换有关可用资源的信息：<ul><li>i）在整个系统中共享资源</li><li>ii）边缘设备在本地执行复杂的查询</li></ul></li></ul></li><li>通过提供有关功能及其属性的某些核心信息来描述资源。这种类型的描述称为资源的元数据，在边缘设备之间复制并以分布式的方式存储。</li><li>根据每个边缘设备的资源偏好处理隐私方面，确保并非所有资源都在整个系统中公布</li></ul><p>邻居集群是通过使用系统调用（即 <em>traceroute 命令</em>）来找到的，该命令估计与其他集群协调器的接近程度（即，使用跃点计数和延迟）。</p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>城市自然灾害，无人机配备多种计算能力和传感器。考虑三层云基础设施：云、雾、边缘。雾设备提供计算和长期存储功能。</p><p><img src="/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/457e80d23580c0ab8e4beb10140d9ec.png" alt="457e80d23580c0ab8e4beb10140d9ec"></p><p>每个簇都有一个协调器设备（即带有绿色圆圈）和一个全局协调器设备（即带有红色和绿色圆圈）。我们假设集群协调器充当<em>超级对等体</em> [35] 。每个集群协调器都跟踪同一集群中的其他协调器和设备（即 IP 地址、端口）。同样，同一集群中的边缘设备相互存储信息，并始终了解其集群协调器和全局协调器。集群协调器可能对设备子集承担各种职责（即，监视、发现资源等）。全局协调器负责监控协调器，在集群之间交换资源描述，并在边缘云基础设施中编排边缘应用程序（即控制弹性、迁移任务等）。</p><p><img src="/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/a7199fbb7f2767e16e35572d17ad13f.png" alt="a7199fbb7f2767e16e35572d17ad13f"></p><p>在本文中，我们主要关注三个方面：i）在边缘邻域中组织边缘设备，ii）确定最适合放置全局和集群协调器的设备，以及iii）在异构和动态的边缘邻域上实现自动资源发现。</p><h1 id="资源切换"><a href="#资源切换" class="headerlink" title="资源切换"></a>资源切换</h1><p>资源切换是指当移动设备在不同的网络环境或物理位置间移动时，需要无缝地切换正在使用的边缘资源。例如，当设备从一个边缘节点移动到另一个节点的覆盖范围内时，需要确保计算任务的迁移不会影响用户体验。这包括数据迁移、会话保持以及计算任务的状态保持等技术。</p><h2 id="一些算法-1"><a href="#一些算法-1" class="headerlink" title="一些算法"></a>一些算法</h2><h3 id="1-基于信号强度的切换（Signal-Strength-Based-Handoff）"><a href="#1-基于信号强度的切换（Signal-Strength-Based-Handoff）" class="headerlink" title="1. 基于信号强度的切换（Signal Strength-Based Handoff）"></a>1. <strong>基于信号强度的切换（Signal Strength-Based Handoff）</strong></h3><ul><li>方法设计：<ul><li><strong>信号测量：</strong> 移动设备通过持续测量当前连接节点的信号强度。当信号强度低于阈值时，触发切换。</li><li><strong>切换策略：</strong> 系统会搜索周围其他边缘节点的信号强度，并选择信号最强的节点进行切换。</li><li><strong>优点：</strong> 简单直观，易于实现。</li><li><strong>挑战：</strong> 容易产生频繁切换，特别是在信号强度波动较大的情况下。</li></ul></li></ul><h3 id="2-基于位置预测的切换（Location-Prediction-Based-Handoff）"><a href="#2-基于位置预测的切换（Location-Prediction-Based-Handoff）" class="headerlink" title="2. 基于位置预测的切换（Location Prediction-Based Handoff）"></a>2. <strong>基于位置预测的切换（Location Prediction-Based Handoff）</strong></h3><ul><li>方法设计：<ul><li><strong>位置跟踪：</strong> 使用GPS或其他定位技术跟踪设备的位置变化。</li><li><strong>运动预测：</strong> 通过历史位置数据和运动模式预测设备的未来位置，从而提前确定可能的切换节点。</li><li><strong>优点：</strong> 提前准备切换，减少服务中断。</li><li><strong>挑战：</strong> 需要精确的运动预测算法，且在复杂环境下定位精度可能受限。</li></ul></li></ul><h3 id="3-基于负载均衡的切换（Load-Balancing-Based-Handoff）"><a href="#3-基于负载均衡的切换（Load-Balancing-Based-Handoff）" class="headerlink" title="3. 基于负载均衡的切换（Load Balancing-Based Handoff）"></a>3. <strong>基于负载均衡的切换（Load Balancing-Based Handoff）</strong></h3><ul><li>方法设计：<ul><li><strong>负载监控：</strong> 持续监控当前边缘节点的计算和网络负载，当负载超过设定的阈值时，启动切换。</li><li><strong>动态分配：</strong> 切换到负载较轻的节点，以保证服务质量（QoS）。</li><li><strong>优点：</strong> 保证节点的高效利用，防止过载。</li><li><strong>挑战：</strong> 可能引入额外的延迟，尤其是在负载波动较大时。</li></ul></li></ul><h3 id="4-基于延迟感知的切换（Latency-Aware-Handoff）"><a href="#4-基于延迟感知的切换（Latency-Aware-Handoff）" class="headerlink" title="4. 基于延迟感知的切换（Latency-Aware Handoff）"></a>4. <strong>基于延迟感知的切换（Latency-Aware Handoff）</strong></h3><ul><li>方法设计：<ul><li><strong>延迟测量：</strong> 持续监测当前节点到设备之间的通信延迟。</li><li><strong>切换决策：</strong> 当延迟超过某个阈值时，系统将设备切换到延迟较低的节点。</li><li><strong>优点：</strong> 提高用户体验，适合对延迟敏感的应用（如视频流或在线游戏）。</li><li><strong>挑战：</strong> 需要实时的延迟监测，并且在网络拥塞时可能难以找到更好的节点。</li></ul></li></ul><h3 id="5-基于上下文感知的切换（Context-Aware-Handoff）"><a href="#5-基于上下文感知的切换（Context-Aware-Handoff）" class="headerlink" title="5. 基于上下文感知的切换（Context-Aware Handoff）"></a>5. <strong>基于上下文感知的切换（Context-Aware Handoff）</strong></h3><ul><li>方法设计：<ul><li><strong>多参数感知：</strong> 结合多种上下文信息（如设备电量、用户行为、网络状况）来做出切换决策。</li><li><strong>自适应切换：</strong> 根据不同的应用需求和用户偏好，动态调整切换策略。</li><li><strong>优点：</strong> 更智能的切换决策，提高服务的个性化体验。</li><li><strong>挑战：</strong> 系统复杂度高，需要处理和分析大量上下文信息。</li></ul></li></ul><h3 id="6-基于AI-ML的切换（AI-ML-Based-Handoff）"><a href="#6-基于AI-ML的切换（AI-ML-Based-Handoff）" class="headerlink" title="6. 基于AI&#x2F;ML的切换（AI&#x2F;ML-Based Handoff）"></a>6. <strong>基于AI&#x2F;ML的切换（AI&#x2F;ML-Based Handoff）</strong></h3><ul><li>方法设计：<ul><li><strong>机器学习模型：</strong> 通过训练模型来预测最优切换节点，学习不同环境下的最佳切换策略。</li><li><strong>强化学习：</strong> 使用强化学习算法，设备和边缘节点可以在运行中不断优化切换策略。</li><li><strong>优点：</strong> 适应复杂动态环境，能够自动调整切换策略。</li><li><strong>挑战：</strong> 需要大量数据和计算资源，且训练过程可能较为复杂。</li></ul></li></ul><h3 id="7-基于多路径的切换（Multi-Path-Based-Handoff）"><a href="#7-基于多路径的切换（Multi-Path-Based-Handoff）" class="headerlink" title="7. 基于多路径的切换（Multi-Path-Based Handoff）"></a>7. <strong>基于多路径的切换（Multi-Path-Based Handoff）</strong></h3><ul><li>方法设计：<ul><li><strong>多路径连接：</strong> 在设备同时保持多个边缘节点的连接，选择最佳路径传输数据。</li><li><strong>切换时机：</strong> 当主路径的性能下降时，系统自动切换到次优路径，确保服务连续性。</li><li><strong>优点：</strong> 提高了切换的可靠性和稳定性。</li><li><strong>挑战：</strong> 资源开销较大，且管理多路径连接的复杂性较高。</li></ul></li></ul><h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><h3 id="多用户异构密集蜂窝网络的高能效业务迁移"><a href="#多用户异构密集蜂窝网络的高能效业务迁移" class="headerlink" title="多用户异构密集蜂窝网络的高能效业务迁移"></a>多用户异构密集蜂窝网络的高能效业务迁移</h3><blockquote><p>X. Zhou, S. Ge, T. Qiu, K. Li and M. Atiquzzaman, “Energy-Efficient Service Migration for Multi-User Heterogeneous Dense Cellular Networks,” in <em>IEEE Transactions on Mobile Computing</em>, vol. 22, no. 2, pp. 890-905, 1 Feb. 2023, doi: 10.1109&#x2F;TMC.2021.3087198. </p></blockquote><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>业务迁移作为一个优化问题，目的是在满足服务延迟要求的同时，同时考虑到不同用户之间的干扰，最大限度地降低平均能耗。</p><p>开发了一种基于 Lyapunov 和粒子群优化的高效节能在线算法，称为 EGO，可以在不预测用户轨迹的情况下解决原始问题。</p><h4 id="方法设计"><a href="#方法设计" class="headerlink" title="方法设计"></a>方法设计</h4><p>在每个基站设置三层结构：</p><p><strong>基础层（Base layer）</strong>：这是最底层的，类似于操作系统，是每个边缘服务器上通用的部分。无论是哪种服务或用户，这一层都是一致的，负责提供基本的计算资源和环境支持。</p><p><strong>应用层（Application layer）</strong>：这一层位于基础层之上，由多个用户共享。它包含了特定的服务应用程序，也就是运行在边缘服务器上的实际业务逻辑和功能。当不同用户请求相同的服务时，他们会共享同一个应用层。</p><p><strong>实例层（Instance layer）</strong>：这是最上层，与具体的用户绑定，包含该用户的服务状态信息，比如请求历史、用户信息以及其他私密数据。每个用户的实例层都是独立的，用于保存用户的个性化数据。</p><p>如果目标边缘服务器中已经部署了应用层，则用户只需从上一个服务节点（相邻的 BS）迁移其实例层即可。否则，用户需要同时迁移应用层和实例层。</p><p><img src="/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/4289053e3bb42f73ed69cb27ad5fa26.png" alt="4289053e3bb42f73ed69cb27ad5fa26"></p><h4 id="具体建模"><a href="#具体建模" class="headerlink" title="具体建模"></a>具体建模</h4><img src="/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/image-20240829171208329.png" class title="image-20240829171208329"><p>这个公示代表，用户在某一时间槽只连接到一个基站：</p><img src="/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/image-20240829171251798.png" class title="image-20240829171251798"><p>这个$$x’$$是指的t时刻将要迁移的服务，感觉有点导数的那个意思，也即下一时刻的状态</p><img src="/2024/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/08/21/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86%EF%BC%88Mobility-Management%EF%BC%89/image-20240829171354917.png" class title="image-20240829171354917"><p>这个是指t时刻n基站上的m服务，如果存在有人在申请（$$\ge1$$），那么这个$$P_t(m,n)$$（<strong>P</strong>lace服务的数量）就是1，如果一个都没申请，那么就是0.</p><p>用八元组来表示一个服务：<br>$$<br>&lt;λ_m,γ_m,D_m,f_{m,u},θ^A_m,θ^I_{m,u},W_m,ω_m&gt;<br>$$<br>具体含义见上面的表格</p><p>以下三个公式分别对基站$$n$$上某个时刻迁移服务时的最大CPU频率、最大存储容量、最大信道带宽进行了约束，就是在任何一个时刻，迁移时的这三个值都不得超过最大值<br>$$<br>\begin{equation*} \sum \limits <em>{m&#x3D;1}^M\sum \limits <em>{u&#x3D;1}^U f</em>{m,u} x</em>{m,t}^\prime (u,n) \leq F_n,\forall t,n, \end{equation*}<br>$$</p><p>$$<br>\begin{equation*} \sum \limits _{m&#x3D;1}^M\Bigg [\sum \limits _{u&#x3D;1}^U \theta <em>{m,u}^I x</em>{m,t}^\prime (u,n) + \theta _m^A P_t^\prime (m,n)\Bigg ] \leq S_n,\forall t,n,\end{equation*}<br>$$</p><p>$$<br>\begin{equation*} \sum \limits <em>{m&#x3D;1}^M \sum \limits <em>{u&#x3D;1}^U W</em>{m,u} x</em>{m,t}^\prime (u,n) \leq W_n,\forall t,n, \end{equation*}<br>$$</p><p>传输速率: $$\begin{equation*} R(a,b)&#x3D;W\log <em>{2}\left(1+\frac{p</em>{a} h d(a,b)^{-3}}{N_0}\right) \end{equation*}$$，其实我感觉这里面的符号都不太用看</p><p>传输延迟包含两部分，第一部分是用户将请求发送到其连接的基站（BS）的延迟。这部分的精确时间无法捕获，用常数$$C$$表示；第二部分是从用户连接的基站传到用户服务的基站（这里不太理解，连接的基站不就是服务的基站？还是说是切换后的这样的基站？<strong>实际上这里讨论的是，如果某个连接的基站上没有某项服务，那么他会通过路由将请求转发到有服务的基站上，所以这应该是不考虑应用迁移，只考虑路由转发的情况</strong>）传输延迟计算公式：<br>$$<br>\begin{equation*} l_{m,t}^{tra}(u) &#x3D; \frac{\lambda _m}{ R(\pi _{t,u}^c,\pi _{m,t,u})} + C \end{equation*}<br>$$<br>其中：<br>$$<br>\begin{equation*} \pi _{t,u}^c&#x3D;\arg\max \limits <em>{n} x</em>{t}^c(u,n)\end{equation*}<br>$$</p><p>$$<br>\begin{equation*} \pi _{m,t,u}&#x3D;\arg \max \limits <em>{n} x</em>{m,t}(u,n)\end{equation*}<br>$$</p><p>其实就是从t时刻用户连接的那个BS传到t时刻用户访问服务的BS</p><p>计算延迟：<br>$$<br>\begin{equation*} l_{m,t}^{com}(u) &#x3D; \frac{\lambda <em>m\gamma <em>m}{f</em>{m,u}}\end{equation*}<br>$$<br><strong>如果是服务迁移</strong>，从一个基站$$n$$迁移到另一个基站$$n’$$，迁移延迟是<br>$$<br>\begin{equation*} l</em>{m,t}^{app}(n) &#x3D; \min \bigg\lbrace \frac{\theta <em>m^A |P_t^\prime (m,n)-P</em>{t}(m,n)|}{P_t^\prime (m,n^\prime)R(n,n^\prime)}|n^\prime &#x3D; 1,\ldots,N\bigg\rbrace  \end{equation*}<br>$$</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><blockquote><p>P. Lang, D. Tian, X. Duan, J. Zhou, Z. Sheng and V. C. M. Leung, “Blockchain-Based Cooperative Computation Offloading and Secure Handover in Vehicular Edge Computing Networks,” in IEEE Transactions on Intelligent Vehicles, vol. 8, no. 7, pp. 3839-3853, July 2023, doi: 10.1109&#x2F;TIV.2023.3271367.</p></blockquote><h3 id="基于预测"><a href="#基于预测" class="headerlink" title="基于预测"></a>基于预测</h3><blockquote><p>P. Guan, Y. Li and A. Taherkordi, “A Prediction Based Resource Reservation Algorithm for Service Handover in Edge Computing,” 2023 IEEE 10th International Conference on Cyber Security and Cloud Computing (CSCloud)&#x2F;2023 IEEE 9th International Conference on Edge Computing and Scalable Cloud (EdgeCom), Xiangtan, Hunan, China, 2023, pp. 330-335, doi: 10.1109&#x2F;CSCloud-EdgeCom58631.2023.00063.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;资源发现&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;一些算法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-------------directory-based-resource-di</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式系统" scheme="http://gladiouszhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="边缘计算" scheme="http://gladiouszhang.github.io/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>边缘计算论文阅读</title>
    <link href="http://gladiouszhang.github.io/2024/08/14/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://gladiouszhang.github.io/2024/08/14/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2024-08-13T17:48:59.000Z</published>
    <updated>2024-11-07T15:54:17.358Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#energy-consumption-and-qos-aware-co-offloading-for-vehicular-edge-computing">Energy Consumption and QoS-Aware Co-Offloading for Vehicular Edge Computing</a><ul><li><a href="#----">论文背景</a></li><li><a href="#----">论文思路</a></li><li><a href="#----">实验部分</a></li></ul></li><li><a href="#deep-graph-based-reinforcement-learning-for-joint-cruise-control-and-task-offloading-for-aerial-edge-internet-of-things--edgeiot-">Deep Graph-based Reinforcement Learning for Joint Cruise Control and Task Offloading for Aerial Edge Internet-of-Things (EdgeIoT)</a><ul><li><a href="#----">论文背景</a></li><li><a href="#----">论文思路</a><ul><li><a href="#----">具体模型</a></li></ul></li></ul></li></ul><!-- tocstop --><h1 id="Energy-Consumption-and-QoS-Aware-Co-Offloading-for-Vehicular-Edge-Computing"><a href="#Energy-Consumption-and-QoS-Aware-Co-Offloading-for-Vehicular-Edge-Computing" class="headerlink" title="Energy Consumption and QoS-Aware Co-Offloading for Vehicular Edge Computing"></a>Energy Consumption and QoS-Aware Co-Offloading for Vehicular Edge Computing</h1><h2 id="论文背景"><a href="#论文背景" class="headerlink" title="论文背景"></a>论文背景</h2><p>该论文探究在满足QoS前提下，尽可能降低能量开销的边缘计算。因为如果只追求低时延，可能会存在资源被浪费（例如大量任务被卸载到边缘端，过度分配资源，也就是增加了能量开销），只需要满足QoS就行，在这个前提下，尽可能的降低能量开销，是本文的核心任务。</p><h2 id="论文思路"><a href="#论文思路" class="headerlink" title="论文思路"></a>论文思路</h2><p>论文的目的是求出卸载率$\lambda_n$（卸载多少）和RES的计算资源分配情况（往哪卸载）。在本文中，首先进行建模</p><p><img src="/2024/08/14/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20240814022118539.png" alt="image-20240814022118539"></p><p>然后对这个建好的模型进行求解。求解的过程中使用贝叶斯优化算法。先确定几个采样点，然后基于采集函数，在采集函数的最大值点设立新的采集点，以此类推，来拟合函数，找到近似的最大值点。</p><p><img src="/2024/08/14/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20240814022410081.png" alt="image-20240814022410081"></p><p>探索（exploration）是指选择代理模型预测不确定性较高的点，这些点可能尚未被充分评估。</p><p>利用（exploitation）是指优先选择那些已经被评估并且表现良好的区域，以期获得更好的结果。</p><p>提出了一个评价模型，是基于QoS和能量二元评价模型，返回值属于0-1：</p><p><img src="/2024/08/14/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20240815021727908.png" alt="image-20240815021727908"></p><p>（感觉baseline就是自己提出的一种极端情况，不一定和别人的论文进行对比）</p><p>随着高维搜索空间的增长，BO变得缓慢。提出一种调优机制来收紧采样过程中的搜索空间：</p><p><img src="/2024/08/14/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20240815022316105.png" alt="image-20240815022316105"></p><p>在保持任务卸载比例不变的情况下，调整资源分配以满足任务的QoS约束。只要调整后的QoS仍然满足，调整是可以接受的。满足的适当减少资源，不满足的适当增加资源。</p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>我感觉就是假设了一些参数，然后对这些参数进行数值分析。</p><p>实验时选择一些已有算法进行对比（<strong>怎么选择？</strong>）</p><p>对比两个方面：</p><ul><li>对比不同计算卸载模型的时延和能耗（分配得更合理）</li><li>对比采用算法的收敛速度（使用的方法更快）</li></ul><h1 id="Deep-Graph-based-Reinforcement-Learning-for-Joint-Cruise-Control-and-Task-Offloading-for-Aerial-Edge-Internet-of-Things-EdgeIoT"><a href="#Deep-Graph-based-Reinforcement-Learning-for-Joint-Cruise-Control-and-Task-Offloading-for-Aerial-Edge-Internet-of-Things-EdgeIoT" class="headerlink" title="Deep Graph-based Reinforcement Learning for Joint Cruise Control and Task Offloading for Aerial Edge Internet-of-Things (EdgeIoT)"></a>Deep Graph-based Reinforcement Learning for Joint Cruise Control and Task Offloading for Aerial Edge Internet-of-Things (EdgeIoT)</h1><h2 id="论文背景-1"><a href="#论文背景-1" class="headerlink" title="论文背景"></a>论文背景</h2><p>背景：无人机作为移动边缘服务器，处理地面物联网设备的任务。</p><p>存在的问题：当无人机调度一个物联网设备卸载其计算任务时，在其他未被选中的设备上缓存的任务可能会过期而不得不取消。</p><p>提出一种优化方案，在物联网设备的计算能力和电池预算以及无人机的速度限制下，最大化卸载到无人机的任务。</p><p>求解这个方案的问题：优化包含较大的解空间，而无人机的瞬时网络状态是未知的。</p><h2 id="论文思路-1"><a href="#论文思路-1" class="headerlink" title="论文思路"></a>论文思路</h2><p>在物联网设备的计算能力和电池预算以及无人机的速度限制下，以卸载到无人机的计算任务数量最大化为目标，建立优化模型。<strong>所以优化目标其实是无人机的速度、方向和物联网设备上的任务调度情况。</strong></p><p>提出了一种新的基于深度图的强化学习框架。开发了一种优势演员-评论家( A2C )结构，用于训练无人机在物联网设备的飞行速度、航向和卸载时间表方面的实时连续动作。</p><blockquote><p>假设你有一群朋友，每个人之间都有各种关系，比如谁是好朋友，谁经常一起出去玩，谁在社交媒体上互相关注等。你可以把每个人看作一个“节点”，而这些朋友之间的关系可以看作是“边”。如果我们把这群朋友及其关系画出来，你就得到了一个“图”。</p><p><strong>深度图（Deep Graph）</strong> 是用来处理这种“图”的一种计算方法。它不仅考虑了直接的关系（比如你和某个朋友的关系），还考虑了间接的关系（比如你朋友的朋友可能也会影响你）。通过使用深度学习的方法（如图神经网络），深度图可以从这种复杂的关系网中提取出有用的信息，比如谁在这群朋友中最有影响力，或者预测谁将成为好朋友。</p><p>想象一个游戏中的AI角色（演员），它负责在游戏世界中移动、攻击敌人、或收集资源。每次它做出一个动作（如移动到特定位置），评论家（Critic）会评估这个动作的结果，给出这个动作相对于当前状态下的其他可能动作的好坏程度（优势）。如果角色选择了一个带来高分数的动作，评论家会告诉演员“这个选择很好”，演员就会增加在类似情况下选择这个动作的概率。反之，如果动作结果不好，评论家会告诉演员“这不是一个好选择”，演员就会减少选择该动作的概率。通过这种方式，AI角色逐渐学会在不同的游戏状态下做出最佳的决策。</p></blockquote><p>本文提出的GNN - A2C中开发了一个长短期记忆( long short-term memory，LSTM )模型，基于GNN中提取的特征来预测物联网设备上的时变无人机地面信道和任务生成。</p><h3 id="具体模型"><a href="#具体模型" class="headerlink" title="具体模型"></a>具体模型</h3><p>暂存一下符号的意思</p><p><img src="/2024/08/14/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20240816023628673.png" alt="image-20240816023628673"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#energy-consumption-and-qos-aware-co-offloading-for-vehicular-edge-computing&quot;&gt;Energy Consumption and QoS-Awa</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式系统" scheme="http://gladiouszhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="边缘计算" scheme="http://gladiouszhang.github.io/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>k8s实现pod内部的webshell</title>
    <link href="http://gladiouszhang.github.io/2024/08/13/k8s%E5%AE%9E%E7%8E%B0pod%E5%86%85%E9%83%A8%E7%9A%84webshell/"/>
    <id>http://gladiouszhang.github.io/2024/08/13/k8s%E5%AE%9E%E7%8E%B0pod%E5%86%85%E9%83%A8%E7%9A%84webshell/</id>
    <published>2024-08-13T07:58:27.000Z</published>
    <updated>2024-08-13T16:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">背景介绍</a></li><li><a href="#----">代码介绍</a><ul><li><a href="#-handleconnections-"><code>handleConnections</code></a></li></ul></li></ul><!-- tocstop --><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>这是实习的时候，公司让我开发的一个功能，主要希望实现的是前端与k8s中的pod的webshell功能，并且包含tab代码补全的功能。基于<a href="https://github.com/GanonYou/k8s-webshell-gin%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82%E4%BD%86%E6%98%AF%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9A%E6%BA%90%E4%BB%A3%E7%A0%81%E6%98%AF%E8%87%AA%E5%B7%B1%E6%9A%B4%E9%9C%B2%E5%87%BAws%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%AD%89%E5%BE%85%E5%89%8D%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%89%EF%BC%8C%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E9%9B%86%E7%BE%A4%E5%85%88%E5%92%8C%E5%90%8E%E7%AB%AF%E5%BB%BA%E7%AB%8Bws%EF%BC%8C%E7%84%B6%E5%90%8E%E7%AD%89%E5%BE%85%E5%89%8D%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%90%8E%E7%AB%AF%EF%BC%8C%E7%84%B6%E5%90%8E%E5%89%8D%E7%AB%AF%E5%85%88%E6%8A%8A%E6%B6%88%E6%81%AF%E4%BC%A0%E5%88%B0%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%90%8E%E7%AB%AF%E7%BB%8F%E8%BF%87%E9%89%B4%E6%9D%83%E5%86%8D%E8%BD%AC%E5%8F%91%E7%BB%99%E9%9B%86%E7%BE%A4%E3%80%82">https://github.com/GanonYou/k8s-webshell-gin的代码来实现的。但是实现流程不一样：源代码是自己暴露出ws接口，等待前端连接），我的代码是集群先和后端建立ws，然后等待前端连接后端，然后前端先把消息传到后端，后端经过鉴权再转发给集群。</a></p><p>在本文档里，大致解释一下集群上的webshell（相当于是后端）的相关代码。</p><h1 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h1><h2 id="handleConnections"><a href="#handleConnections" class="headerlink" title="handleConnections"></a><code>handleConnections</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sshReq = ClientSet.CoreV1().RESTClient().Post().</span><br><span class="line">Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">Name(pod).</span><br><span class="line">Namespace(namespace).</span><br><span class="line">SubResource(<span class="string">&quot;exec&quot;</span>).</span><br><span class="line">VersionedParams(&amp;v1.PodExecOptions&#123;</span><br><span class="line">Container: container,</span><br><span class="line">Command:   []<span class="type">string</span>&#123;<span class="string">&quot;bash&quot;</span>&#125;,</span><br><span class="line">Stdin:     <span class="literal">true</span>,</span><br><span class="line">Stdout:    <span class="literal">true</span>,</span><br><span class="line">Stderr:    <span class="literal">true</span>,</span><br><span class="line">TTY:       <span class="literal">true</span>,</span><br><span class="line">&#125;, scheme.ParameterCodec)</span><br></pre></td></tr></table></figure><p>以上只是用于创建一个请求，还未发送。</p><p><code>ClientSet</code>是一个指向 <code>kubernetes.Clientset</code> 类型的实例的指针，CoreV1提供了对 Kubernetes Core API 组，例如 Pods、Nodes、Services 等资源的访问，<code>RESTClient()</code>返回一个 <code>rest.Interface</code> 对象，允许直接使用 REST API 请求而不通过高层次的抽象。这个对象提供了更底层的 API 操作。最后，<code>Post()</code>用于构造一个 HTTP POST 请求。这个请求会用来与 Kubernetes API 交互，通常用于创建或更新资源。</p><p><code>SubResource(&quot;exec&quot;)</code> 表示我们要操作的是 Pod 的 exec 子资源，这通常用于执行命令。即，我们希望在指定的 Pod 内执行某个命令。</p><p><code>VersionedParams()</code>用于设置请求的参数，并且按照 API 版本对这些参数进行编码。</p><ul><li><code>v1.PodExecOptions</code>中：<ul><li><strong><code>Container</code></strong>: 要执行命令的容器名。</li><li><strong><code>Command</code></strong>: 要在容器中执行的命令数组。这里是 <code>[]string&#123;&quot;bash&quot;&#125;</code>，表示在容器中启动一个 Bash shell。</li><li><strong><code>Stdin</code>, <code>Stdout</code>, <code>Stderr</code></strong>: 这些布尔值表示是否需要连接标准输入、标准输出和标准错误。</li><li><strong><code>TTY</code></strong>: 布尔值，表示是否需要终端</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建到容器的连接</span></span><br><span class="line"><span class="keyword">if</span> executor, err = remotecommand.NewSPDYExecutor(restConf, <span class="string">&quot;POST&quot;</span>, sshReq.URL()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个 <code>remotecommand.Executor</code> 对象，以便能够通过 Kubernetes API 执行命令。创建 <code>executor</code> 的过程涉及配置 API 连接、指定 HTTP 方法（<code>POST</code>）以及构造执行请求的 URL。</p><p><strong><code>sshReq.URL()</code></strong>:</p><ul><li><code>sshReq</code> 是之前构建的 <code>*rest.Request</code> 对象，包含了 Kubernetes API 的请求信息。</li><li><code>sshReq.URL()</code> 返回一个 <code>*url.URL</code> 对象，表示请求的完整 URL。这个 URL 指向 Kubernetes API 的 exec 子资源，用于执行命令。</li><li>例如，这个 URL 可能类似于 <code>https://kubernetes/api/v1/namespaces/default/pods/my-pod/exec?stdin=true&amp;stdout=true&amp;stderr=true</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handler = &amp;streamHandler&#123;wsConn: wsConn&#125;</span><br><span class="line">ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = executor.StreamWithContext(ctx, remotecommand.StreamOptions&#123;</span><br><span class="line">Stdin:  handler,</span><br><span class="line">Stdout: handler,</span><br><span class="line">Stderr: handler,</span><br><span class="line"><span class="comment">// TerminalSizeQueue: handler,</span></span><br><span class="line">Tty: <span class="literal">true</span>,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将websocket直接连接到容器内的Stdin等。其实我修改后可以不用streamHandler，直接给我们的websocket加上io.read和write的接口就行，但是现在还没改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;代码介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#-handleconnections-&quot;&gt;&lt;code&gt;handleConnect</summary>
      
    
    
    
    
    <category term="分布式系统" scheme="http://gladiouszhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="实习项目" scheme="http://gladiouszhang.github.io/tags/%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>边缘计算综述</title>
    <link href="http://gladiouszhang.github.io/2024/08/02/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B0/"/>
    <id>http://gladiouszhang.github.io/2024/08/02/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B0/</id>
    <published>2024-08-02T14:39:15.000Z</published>
    <updated>2024-08-16T06:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">研究热点</a><ul><li><a href="#----">关键技术</a><ul><li><a href="#----">计算卸载</a></li><li><a href="#----">移动管理</a></li><li><a href="#----">流量卸载</a></li><li><a href="#----">缓存加速</a></li><li><a href="#----">网络控制</a></li></ul></li><li><a href="#---------">数据安全和隐私保护</a><ul><li><a href="#----">四个挑战</a></li><li><a href="#----">研究体系</a></li></ul></li></ul></li></ul><!-- tocstop --><blockquote><p>K. Cao, Y. Liu, G. Meng和Q. Sun, 《An Overview on Edge Computing Research》, <em>IEEE Access</em>, 卷 8, 页 85714–85728, 2020, doi: <a href="https://doi.org/10.1109/ACCESS.2020.2991734">10.1109&#x2F;ACCESS.2020.2991734</a>.</p></blockquote><h2 id="研究热点"><a href="#研究热点" class="headerlink" title="研究热点"></a>研究热点</h2><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><h4 id="计算卸载"><a href="#计算卸载" class="headerlink" title="计算卸载"></a>计算卸载</h4><p>资源受限设备将资源密集型计算从移动设备上部分或全部地移植到资源富集的临近设备：</p><ul><li>卸载决策</li></ul><p>如何卸载计算任务，卸载多少，卸载些啥。</p><p>分为三个部分：编码阶段决定要卸载什么，系统阶段监控变量（带宽、数据大小等），决策引擎决定是否卸载</p><p>决策结果分为三种情况：本地执行（不卸载）、部分卸载、全部卸载。</p><p>决策的目标可以被分为（分别满足）：减小延迟、降低能量开销、平衡能量开销和延迟</p><ul><li>资源分配</li></ul><p>往哪卸载。比如有些部分不能拆分，或者拆分后有联系的，就必须放在同样的MEC(Mobile Edge Computing)服务器。</p><p>通常分配节点被分为单点分配和多点分配。</p><h4 id="移动管理"><a href="#移动管理" class="headerlink" title="移动管理"></a>移动管理</h4><p>一个边缘计算节点只服务于其周围的人。</p><p>主要问题是资源发现和资源切换。</p><ul><li>资源发现</li></ul><p>用户在移动中快速发现周围的可用资源，并选择最合适的资源。</p><ul><li>资源切换</li></ul><p>当用户移动时，移动应用所使用的计算资源可能会在多个设备之间进行切换，同时会改变服务程序的工作站点来保证服务连续性。</p><h4 id="流量卸载"><a href="#流量卸载" class="headerlink" title="流量卸载"></a>流量卸载</h4><p>将满足特定卸载规则的流量卸载到移动边缘网络(即一个局部特定的网络,可以是内部网,也可以是因特网)，以节省回程带宽，减少延迟，并促进其他MEC服务的扩展。</p><blockquote><p>假设你在一个繁忙的购物中心使用手机，正在观看一个高清的实时视频。传统情况下，所有的数据请求都需要通过蜂窝网络的核心网传输，然后通过互联网访问视频内容服务器。由于购物中心的人流量大，蜂窝网络的核心网可能会承载大量的流量，导致网络拥塞、延迟增加。</p><p>为了优化这个场景，网络运营商部署了一个MEC（移动边缘计算）节点，它包含视频内容的本地缓存，并支持流量卸载。当你在购物中心观看视频时，视频流量会被卸载到这个MEC节点。也就是说，视频数据直接从购物中心附近的MEC节点获取，而不是经过蜂窝网络的核心网。这不仅减少了核心网的负担，还显著降低了延迟，提高了视频流的质量。</p></blockquote><p>和计算卸载的区别是，计算卸载是把本地任务卸载到边缘端服务器，流量卸载是将流量负担较大的线路转移。计算卸载重点在于“<strong>任务执行</strong>”的转移，流量卸载重点在于“<strong>数据内容传输</strong>”的转移。</p><h4 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h4><p>内容缓存到移动网络边缘后，用户可以就近获取内容，从而避免了内容的重复传输，缓解了回程网络和核心网的压力。</p><blockquote><p><strong>缓存加速</strong>本质上是一种特定的流量卸载策略，其中的重点是对内容进行本地化存储，以减少传输需求。</p><p><strong>流量卸载</strong>的范围更广，它不仅包括缓存加速，还可能包括其他形式的流量转移或重新路由，目的是减轻核心网络的整体负担。</p></blockquote><h4 id="网络控制"><a href="#网络控制" class="headerlink" title="网络控制"></a>网络控制</h4><p>这一块论文没咋讲，gpt如是说：</p><blockquote><p>网络控制是指在网络基础设施中管理和调度数据流、资源分配以及通信行为的过程和机制。它涉及如何控制网络中的流量、优化性能、确保安全性和稳定性，并响应不同的网络需求。网络控制在整个网络中扮演着关键角色，特别是在大型、复杂的网络环境中，比如在边缘网络和云计算环境中。</p></blockquote><h3 id="数据安全和隐私保护"><a href="#数据安全和隐私保护" class="headerlink" title="数据安全和隐私保护"></a>数据安全和隐私保护</h3><p>边缘计算的分布式结构增加了攻击向量的维度。边缘计算客户端越智能，越容易受到恶意软件的感染和安全漏洞的攻击。网络边缘高度动态的环境也使得网络更加脆弱。</p><h4 id="四个挑战"><a href="#四个挑战" class="headerlink" title="四个挑战"></a>四个挑战</h4><ul><li>轻量级的数据加密和在多个授权团体基础上的细粒度数据分享：</li></ul><p>设计针对多个授权中心的数据加密方法，考虑复杂度。</p><ul><li>分布式计算环境下的多源异构数据传播控制与安全管理：</li></ul><p>用户或数据拥有者希望能够利用有效的信息发布控制和访问控制机制，实现数据的分发、搜索、访问以及对数据授权范围的控制。</p><ul><li>边缘计算大规模互联服务与资源受限终端之间的安全挑战</li><li>面向物联网的多样化服务和边缘计算模式对高效隐私保护的新要求</li></ul><h4 id="研究体系"><a href="#研究体系" class="headerlink" title="研究体系"></a>研究体系</h4><ul><li><p>数据安全</p><p>数据的加密及对其的安全操作。思路是将其他计算范式（如云计算、雾计算等）安全解决方案移植过来，并将计算架构并行化，最终实现一个轻量级的、分布式的数据安全防护系统。</p><ul><li>数据加密和安全数据分享</li></ul></li><li><p>身份认证</p></li><li><p>隐私保护</p></li><li><p>访问控制</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;研究热点&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;关键技术&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;计算卸载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;移</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式系统" scheme="http://gladiouszhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="边缘计算" scheme="http://gladiouszhang.github.io/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群minio作pvc挂载介绍及示例</title>
    <link href="http://gladiouszhang.github.io/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/"/>
    <id>http://gladiouszhang.github.io/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/</id>
    <published>2024-07-31T16:33:26.000Z</published>
    <updated>2024-08-11T09:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#minio--">MinIO介绍</a></li><li><a href="#pvc---persistent-volume-claim-">PVC概念（Persistent Volume Claim）</a></li><li><a href="#minio-pvc---">MinIO与PVC的结合</a></li><li><a href="#----">配置步骤</a><ul><li><a href="#--------">创建相关存储服务</a><ul><li><a href="#1---persistent-volume--pv----persistent-volume-claim--pvc-">1. 创建Persistent Volume (PV) 和 Persistent Volume Claim (PVC)</a></li></ul></li></ul></li></ul><!-- tocstop --><h3 id="MinIO介绍"><a href="#MinIO介绍" class="headerlink" title="MinIO介绍"></a>MinIO介绍</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/yuxl01/p/16226701.html">https://www.cnblogs.com/yuxl01/p/16226701.html</a></p></blockquote><p>MinIO 是一个高性能的对象存储系统，常用于存储大量非结构化数据，例如图片、视频、备份文件等。它以分布式方式运行，确保数据的高可用性和可靠性。</p><h3 id="PVC概念（Persistent-Volume-Claim）"><a href="#PVC概念（Persistent-Volume-Claim）" class="headerlink" title="PVC概念（Persistent Volume Claim）"></a>PVC概念（Persistent Volume Claim）</h3><p>在Kubernetes中，Persistent Volume (PV) 是集群中由管理员提供的一块存储资源，而Persistent Volume Claim (PVC) 则是用户对存储资源的请求。PVC允许用户动态地申请存储资源，并将其挂载到Pod中，以便持久存储数据。</p><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/8b14f155277d1a69c943a8c75f64a342.png"></p><h3 id="MinIO与PVC的结合"><a href="#MinIO与PVC的结合" class="headerlink" title="MinIO与PVC的结合"></a>MinIO与PVC的结合</h3><p>将MinIO作为PVC挂载使用，可以使应用程序方便地使用MinIO提供的存储资源，并且通过Kubernetes的调度和管理功能，保证存储服务的高可用性和可扩展性。</p><p>大致流程如下：</p><p><strong>用户</strong> &lt;–&gt; <strong>MinIO</strong>：用户上传或下载数据。</p><p><strong>MinIO</strong> &lt;–&gt; <strong>PVC</strong>：MinIO的部署配置请求存储资源（PVC）。</p><p><strong>PVC</strong> &lt;–&gt; <strong>PV</strong>：Kubernetes将PVC绑定到合适的PV，提供实际的存储资源。</p><p><strong>PV</strong>：实际存储数据的位置。</p><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p>写一个简单的demo，演示一下上传一条记录到minio的过程</p><h4 id="创建相关存储服务"><a href="#创建相关存储服务" class="headerlink" title="创建相关存储服务"></a>创建相关存储服务</h4><h5 id="1-创建Persistent-Volume-PV-和-Persistent-Volume-Claim-PVC"><a href="#1-创建Persistent-Volume-PV-和-Persistent-Volume-Claim-PVC" class="headerlink" title="1. 创建Persistent Volume (PV) 和 Persistent Volume Claim (PVC)"></a>1. 创建Persistent Volume (PV) 和 Persistent Volume Claim (PVC)</h5><p>创建一个PV配置文件 <code>minio-pv.yaml</code>，给这个PV分配10G空间</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">minio-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">100Mi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/mnt/data&quot;</span></span><br></pre></td></tr></table></figure><p>创建一个PVC配置文件 <code>minio-pvc.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">minio-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">100Mi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><h5 id="2-部署MinIO"><a href="#2-部署MinIO" class="headerlink" title="2. 部署MinIO"></a>2. 部署MinIO</h5><p>创建一个MinIO部署文件 <code>minio-deployment.yaml</code>，使用前面创建的pvc</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">minio-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">minio</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">minio</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">minio</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">minio</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">minio/minio:latest</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">server</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/data</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MINIO_ACCESS_KEY</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;minioadmin&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MINIO_SECRET_KEY</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;minioadmin&quot;</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">minio-storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">minio-storage</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">minio-pvc</span></span><br></pre></td></tr></table></figure><p>创建一个MinIO服务文件 <code>minio-service.yaml</code>，用于提供一种访问方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">minio-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">minio</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">minio</span></span><br></pre></td></tr></table></figure><blockquote><p>踩坑：由于在本地环境下，LoadBalancer 类型的服务不会自动获得一个外部 IP 地址。即：</p><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/image-20240802011313019.png" alt="image-20240802011313019"></p><p>所以改为NodePort类型的服务。</p><p><code>NodePort</code> 是一种服务类型，它在所有集群节点的一个静态端口（NodePort）上为服务开放一个端口。这意味着你可以通过任何节点的 IP 地址加上这个端口来访问服务。</p><p>修改后的yaml文件为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: minio-service</span><br><span class="line">  labels:</span><br><span class="line">    app: minio</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 9000</span><br><span class="line">    targetPort: 9000</span><br><span class="line">    nodePort: 31909 </span><br><span class="line">  selector:</span><br><span class="line">    app: minio</span><br></pre></td></tr></table></figure></blockquote><h5 id="3-应用配置文件"><a href="#3-应用配置文件" class="headerlink" title="3. 应用配置文件"></a>3. 应用配置文件</h5><p>使用 <code>kubectl</code> 命令行工具应用这些配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f minio-pv.yaml</span><br><span class="line">kubectl apply -f minio-pvc.yaml</span><br><span class="line">kubectl apply -f minio-deployment.yaml</span><br><span class="line">kubectl apply -f minio-service.yaml</span><br></pre></td></tr></table></figure><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/image-20240802005201078.png" alt="image-20240802005201078"></p><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/image-20240802005445450.png" alt="image-20240802005445450"></p><h4 id="编写上传记录的Go程序"><a href="#编写上传记录的Go程序" class="headerlink" title="编写上传记录的Go程序"></a>编写上传记录的Go程序</h4><h5 id="1-安装MinIO的Go-SDK"><a href="#1-安装MinIO的Go-SDK" class="headerlink" title="1. 安装MinIO的Go SDK"></a>1. 安装MinIO的Go SDK</h5><p>首先安装MinIO的Go SDK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/minio/minio-go/v7</span><br></pre></td></tr></table></figure><h5 id="2-编写上传记录的Go程序"><a href="#2-编写上传记录的Go程序" class="headerlink" title="2. 编写上传记录的Go程序"></a>2. 编写上传记录的Go程序</h5><p>编写一个简单的Go程序来上传一条记录：</p><blockquote><p>这里有一个桶的概念。桶（Bucket）是用来组织和管理数据的主要容器。每个桶可以包含任意数量的对象（文件），可以把桶想象成一个顶级文件夹，它用来存储数据对象。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/minio/minio-go/v7&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/minio/minio-go/v7/pkg/credentials&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化MinIO客户端</span></span><br><span class="line">    minioClient, err := minio.New(<span class="string">&quot;localhost:9000&quot;</span>, &amp;minio.Options&#123;</span><br><span class="line">        Creds:  credentials.NewStaticV4(<span class="string">&quot;minioadmin&quot;</span>, <span class="string">&quot;minioadmin&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        Secure: <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个桶（bucket）</span></span><br><span class="line">    bucketName := <span class="string">&quot;mybucket&quot;</span></span><br><span class="line">    location := <span class="string">&quot;china&quot;</span></span><br><span class="line">    err = minioClient.MakeBucket(context.Background(), bucketName, minio.MakeBucketOptions&#123;Region: location&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 检查桶是否已经存在</span></span><br><span class="line">        exists, errBucketExists := minioClient.BucketExists(context.Background(), bucketName)</span><br><span class="line">        <span class="keyword">if</span> errBucketExists == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Bucket &#x27;%s&#x27; already exists.\n&quot;</span>, bucketName)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatalln(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Bucket &#x27;%s&#x27; created successfully.\n&quot;</span>, bucketName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传一条记录</span></span><br><span class="line">    recordContent := <span class="string">&quot;This is a test record.&quot;</span></span><br><span class="line">    recordName := <span class="string">&quot;test_record.txt&quot;</span></span><br><span class="line">    _, err = minioClient.PutObject(context.Background(), bucketName, recordName, bytes.NewReader([]<span class="type">byte</span>(recordContent)), <span class="type">int64</span>(<span class="built_in">len</span>(recordContent)), minio.PutObjectOptions&#123;ContentType: <span class="string">&quot;text/plain&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Record uploaded successfully.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3. 运行程序"></a>3. 运行程序</h5><p>将上述Go代码保存为 <code>main.go</code>，然后运行它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/image-20240802015509274.png" alt="image-20240802015509274"></p><h4 id="尝试删、改、查"><a href="#尝试删、改、查" class="headerlink" title="尝试删、改、查"></a>尝试删、改、查</h4><h5 id="上传对象"><a href="#上传对象" class="headerlink" title="上传对象"></a>上传对象</h5><p>直接拆出来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uploadObject</span><span class="params">(minioClient minio.Client, bucketName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 上传一条记录</span></span><br><span class="line">recordContent := <span class="string">&quot;This is a test record.&quot;</span></span><br><span class="line">recordName := <span class="string">&quot;test_record.txt&quot;</span></span><br><span class="line">_, err := minioClient.PutObject(context.Background(), bucketName, recordName, bytes.NewReader([]<span class="type">byte</span>(recordContent)), <span class="type">int64</span>(<span class="built_in">len</span>(recordContent)), minio.PutObjectOptions&#123;ContentType: <span class="string">&quot;text/plain&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Record uploaded successfully.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h5><p>删除一个已经存在的对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeObject</span><span class="params">(minioClient *minio.Client, bucketName, objectName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    err := minioClient.RemoveObject(ctx, bucketName, objectName, minio.RemoveObjectOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Successfully deleted %s\n&quot;</span>, objectName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/image-20240802021949708.png" alt="image-20240802021949708"></p><h5 id="上传（修改）对象"><a href="#上传（修改）对象" class="headerlink" title="上传（修改）对象"></a>上传（修改）对象</h5><p>上传一个新的对象或覆盖一个已经存在的对象可以视为“修改”操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;bytes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyObject</span><span class="params">(minioClient *minio.Client, bucketName, objectName, objectContent <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    reader := bytes.NewReader([]<span class="type">byte</span>(objectContent))</span><br><span class="line">    _, err := minioClient.PutObject(ctx, bucketName, objectName, reader, <span class="type">int64</span>(<span class="built_in">len</span>(objectContent)), minio.PutObjectOptions&#123;ContentType: <span class="string">&quot;text/plain&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Successfully uploaded %s\n&quot;</span>, objectName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/image-20240802021840498.png" alt="image-20240802021840498"></p><h5 id="检索（查）对象"><a href="#检索（查）对象" class="headerlink" title="检索（查）对象"></a>检索（查）对象</h5><p>检索（查）操作包括列出所有对象名称和内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getObjectContent</span><span class="params">(minioClient *minio.Client, bucketName, objectName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 GetObject 获取对象</span></span><br><span class="line">    object, err := minioClient.GetObject(ctx, bucketName, objectName, minio.GetObjectOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> object.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取对象的内容</span></span><br><span class="line">    data, err := io.ReadAll(object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出对象的内容</span></span><br><span class="line">    log.Printf(<span class="string">&quot;Content of %s: %s\n&quot;</span>, objectName, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listObjectsAndContents</span><span class="params">(minioClient *minio.Client, bucketName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    objectCh := minioClient.ListObjects(ctx, bucketName, minio.ListObjectsOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> object := <span class="keyword">range</span> objectCh &#123;</span><br><span class="line">        <span class="keyword">if</span> object.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatalln(object.Err)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">&quot;Found %s\n&quot;</span>, object.Key)</span><br><span class="line">        getObjectContent(minioClient, bucketName, object.Key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/01/k8s%E9%9B%86%E7%BE%A4minio%E4%BD%9Cpvc%E6%8C%82%E8%BD%BD/image-20240802021745453.png" alt="image-20240802021745453"></p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>目前最大的问题是dockerhub访问不了，有解决方式，包括挂代理、<a href="https://zhuanlan.zhihu.com/p/705937780?utm_psn=1802522312492331008">使用cloudflare托管</a>等，我在这里找到了一个暂且还能使用的镜像源<a href="https://docker.1panel.live/">https://docker.1panel.live</a></p><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><h4 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h4><p>服务器端上传加密，将对象通过自定义的密钥加密并上传至服务器，以保护数据安全。使用 encrypt.NewSSEC 函数来创建一个服务器端加密（SSE）对象，该函数接收一个密钥</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7/pkg/credentials&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7/pkg/encrypt&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到Minio服务器</span></span><br><span class="line">endpoint := <span class="string">&quot;play.min.io&quot;</span></span><br><span class="line">accessKeyID := <span class="string">&quot;YOUR-ACCESSKEYID&quot;</span></span><br><span class="line">secretAccessKey := <span class="string">&quot;YOUR-SECRETACCESSKEY&quot;</span></span><br><span class="line">useSSL := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化minio client对象</span></span><br><span class="line">minioClient, err := minio.New(endpoint, &amp;minio.Options&#123;</span><br><span class="line">Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, <span class="string">&quot;&quot;</span>),</span><br><span class="line">Secure: useSSL,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个加密的存储桶</span></span><br><span class="line">bucketName := <span class="string">&quot;encrypted-bucket&quot;</span></span><br><span class="line">location := <span class="string">&quot;us-east-1&quot;</span></span><br><span class="line"></span><br><span class="line">err = minioClient.MakeBucket(context.Background(), bucketName, minio.MakeBucketOptions&#123;Region: location&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 检查是否已经存在</span></span><br><span class="line">exists, errBucketExists := minioClient.BucketExists(context.Background(), bucketName)</span><br><span class="line"><span class="keyword">if</span> errBucketExists == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Bucket %s already exists\n&quot;</span>, bucketName)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Bucket %s created successfully\n&quot;</span>, bucketName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置加密密钥</span></span><br><span class="line">encryptionKey := <span class="string">&quot;MY-ENCRYPTION-KEY&quot;</span></span><br><span class="line">sse := encrypt.NewSSEC([]<span class="type">byte</span>(encryptionKey))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件并加密</span></span><br><span class="line">objectName := <span class="string">&quot;encrypted-file.txt&quot;</span></span><br><span class="line">filePath := <span class="string">&quot;file.txt&quot;</span></span><br><span class="line">contentType := <span class="string">&quot;application/text&quot;</span></span><br><span class="line"></span><br><span class="line">uploadInfo, err := minioClient.FPutObject(context.Background(), bucketName, objectName, filePath, minio.PutObjectOptions&#123;</span><br><span class="line">ContentType:  contentType,</span><br><span class="line">ServerSideEncryption: sse,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Successfully uploaded %s of size %d\n&quot;</span>, objectName, uploadInfo.Size)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个名为“encrypted-bucket”的加密存储桶。然后，设置了一个自定义的加密密钥，并使用该密钥对文件进行加密上传。上传到Minio服务器的文件将以加密形式存储，保护了数据的机密性。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>除了数据加密，Minio还提供了访问控制功能，可以帮助用户控制对存储桶和对象的访问权限。通过设置适当的访问策略，用户可以限制谁可以读取和写入存储桶中的对象，从而提高数据的安全性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7/pkg/credentials&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到Minio服务器</span></span><br><span class="line">endpoint := <span class="string">&quot;play.min.io&quot;</span></span><br><span class="line">accessKeyID := <span class="string">&quot;YOUR-ACCESSKEYID&quot;</span></span><br><span class="line">secretAccessKey := <span class="string">&quot;YOUR-SECRETACCESSKEY&quot;</span></span><br><span class="line">useSSL := <span class="literal">true</span></span><br><span class="line"><span class="comment">// 初始化minio client对象</span></span><br><span class="line">minioClient, err := minio.New(endpoint, &amp;minio.Options&#123;</span><br><span class="line">Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, <span class="string">&quot;&quot;</span>),</span><br><span class="line">Secure: useSSL,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置存储桶的访问策略</span></span><br><span class="line">bucketName := <span class="string">&quot;encrypted-bucket&quot;</span></span><br><span class="line">username := <span class="string">&quot;specific-user&quot;</span> <span class="comment">// 替换为你想允许写入的特定用户的用户名</span></span><br><span class="line"></span><br><span class="line">policy := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">&quot;Version&quot;: &quot;2012-10-17&quot;,</span></span><br><span class="line"><span class="string">&quot;Statement&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;Effect&quot;: &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">&quot;Principal&quot;: &#123;&quot;AWS&quot;: &quot;arn:aws:iam::`</span> + username + <span class="string">`&quot;&#125;,</span></span><br><span class="line"><span class="string">&quot;Action&quot;: [</span></span><br><span class="line"><span class="string">&quot;s3:PutObject&quot;,</span></span><br><span class="line"><span class="string">&quot;s3:DeleteObject&quot;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;Resource&quot;: &quot;arn:aws:s3:::`</span> + bucketName + <span class="string">`/*&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;Effect&quot;: &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">&quot;Principal&quot;: &quot;*&quot;,</span></span><br><span class="line"><span class="string">&quot;Action&quot;: &quot;s3:GetObject&quot;,</span></span><br><span class="line"><span class="string">&quot;Resource&quot;: &quot;arn:aws:s3:::`</span> + bucketName + <span class="string">`/*&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line">err = minioClient.SetBucketPolicy(context.Background(), bucketName, policy)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Bucket policy set successfully.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个策略文档，其中包含两个声明：<br>第一个声明：允许特定用户（通过其ARN表示）进行写操作（包括PutObject和DeleteObject）。<br>第二个声明：允许所有用户进行读操作（GetObject）。</p><h4 id="SSL-TLS支持"><a href="#SSL-TLS支持" class="headerlink" title="SSL&#x2F;TLS支持"></a>SSL&#x2F;TLS支持</h4><p>Minio还支持通过SSL&#x2F;TLS对数据进行安全传输。通过启用SSL&#x2F;TLS，所有传输的数据都将进行加密，从而防止中间人攻击和数据泄露。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7/pkg/credentials&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到启用了SSL/TLS的Minio服务器</span></span><br><span class="line">endpoint := <span class="string">&quot;play.min.io&quot;</span></span><br><span class="line">accessKeyID := <span class="string">&quot;YOUR-ACCESSKEYID&quot;</span></span><br><span class="line">secretAccessKey := <span class="string">&quot;YOUR-SECRETACCESSKEY&quot;</span></span><br><span class="line">useSSL := <span class="literal">true</span></span><br><span class="line"><span class="comment">// 初始化minio client对象</span></span><br><span class="line">minioClient, err := minio.New(endpoint, &amp;minio.Options&#123;</span><br><span class="line">Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, <span class="string">&quot;&quot;</span>),</span><br><span class="line">Secure: useSSL,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Successfully connected to Minio server.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>通过启用版本控制，Minio可以保存对象的多个版本，以防止数据丢失和意外删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7/pkg/credentials&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到Minio服务器</span></span><br><span class="line">endpoint := <span class="string">&quot;play.min.io&quot;</span></span><br><span class="line">accessKeyID := <span class="string">&quot;YOUR-ACCESSKEYID&quot;</span></span><br><span class="line">secretAccessKey := <span class="string">&quot;YOUR-SECRETACCESSKEY&quot;</span></span><br><span class="line">useSSL := <span class="literal">true</span></span><br><span class="line"><span class="comment">// 初始化minio client对象</span></span><br><span class="line">minioClient, err := minio.New(endpoint, &amp;minio.Options&#123;</span><br><span class="line">Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, <span class="string">&quot;&quot;</span>),</span><br><span class="line">Secure: useSSL,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用版本控制</span></span><br><span class="line">bucketName := <span class="string">&quot;my-bucket&quot;</span></span><br><span class="line">err = minioClient.EnableVersioning(context.Background(), bucketName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Versioning enabled successfully.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁定措施"><a href="#锁定措施" class="headerlink" title="锁定措施"></a>锁定措施</h4><p>通过启用对象锁定，Minio可以保护数据免受意外删除或覆盖，并实现数据保留和合规性要求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7/pkg/credentials&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到Minio服务器</span></span><br><span class="line">endpoint := <span class="string">&quot;play.min.io&quot;</span></span><br><span class="line">accessKeyID := <span class="string">&quot;YOUR-ACCESSKEYID&quot;</span></span><br><span class="line">secretAccessKey := <span class="string">&quot;YOUR-SECRETACCESSKEY&quot;</span></span><br><span class="line">useSSL := <span class="literal">true</span></span><br><span class="line"><span class="comment">// 初始化minio client对象</span></span><br><span class="line">minioClient, err := minio.New(endpoint, &amp;minio.Options&#123;</span><br><span class="line">Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, <span class="string">&quot;&quot;</span>),</span><br><span class="line">Secure: useSSL,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用对象锁定</span></span><br><span class="line">bucketName := <span class="string">&quot;my-lock-enabled-bucket&quot;</span></span><br><span class="line">err = minioClient.MakeBucket(context.Background(), bucketName, minio.MakeBucketOptions&#123;ObjectLocking: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Bucket with object lock enabled created successfully.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传带有锁定策略的对象</span></span><br><span class="line">objectName := <span class="string">&quot;my-object.txt&quot;</span></span><br><span class="line">filePath := <span class="string">&quot;path/to/your/file.txt&quot;</span></span><br><span class="line">contentType := <span class="string">&quot;application/text&quot;</span></span><br><span class="line"></span><br><span class="line">lockMode := minio.Governance</span><br><span class="line">retainUntilDate := time.Now().Add(<span class="number">24</span> * time.Hour) <span class="comment">// 保留24小时</span></span><br><span class="line"></span><br><span class="line">uploadInfo, err := minioClient.PutObject(context.Background(), bucketName, objectName, filePath, <span class="number">-1</span>, minio.PutObjectOptions&#123;</span><br><span class="line">ContentType:      contentType,</span><br><span class="line">RetainUntilDate: retainUntilDate,</span><br><span class="line">Mode:            lockMode,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Successfully uploaded %s with lock mode %s until %v\n&quot;</span>, objectName, lockMode, retainUntilDate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据完整性检查"><a href="#数据完整性检查" class="headerlink" title="数据完整性检查"></a>数据完整性检查</h4><p>通过计算文件的哈希值并在上传和下载过程中进行验证，可以确保数据在传输过程中没有被损坏。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/minio/minio-go/v7/pkg/credentials&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到Minio服务器</span></span><br><span class="line">endpoint := <span class="string">&quot;play.min.io&quot;</span></span><br><span class="line">accessKeyID := <span class="string">&quot;YOUR-ACCESSKEYID&quot;</span></span><br><span class="line">secretAccessKey := <span class="string">&quot;YOUR-SECRETACCESSKEY&quot;</span></span><br><span class="line">useSSL := <span class="literal">true</span></span><br><span class="line"><span class="comment">// 初始化minio client对象</span></span><br><span class="line">minioClient, err := minio.New(endpoint, &amp;minio.Options&#123;</span><br><span class="line">Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, <span class="string">&quot;&quot;</span>),</span><br><span class="line">Secure: useSSL,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件并计算哈希值</span></span><br><span class="line">bucketName := <span class="string">&quot;my-bucket&quot;</span></span><br><span class="line">objectName := <span class="string">&quot;my-object.txt&quot;</span></span><br><span class="line">filePath := <span class="string">&quot;path/to/your/file.txt&quot;</span></span><br><span class="line"></span><br><span class="line">file, err := os.Open(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">hash := sha256.New()</span><br><span class="line">tee := io.TeeReader(file, hash)</span><br><span class="line"></span><br><span class="line">uploadInfo, err := minioClient.PutObject(context.Background(), bucketName, objectName, tee, <span class="number">-1</span>, minio.PutObjectOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Successfully uploaded %s of size %d\n&quot;</span>, objectName, uploadInfo.Size)</span><br><span class="line">log.Printf(<span class="string">&quot;SHA-256 hash: %x\n&quot;</span>, hash.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载文件并验证哈希值</span></span><br><span class="line">downloadFilePath := <span class="string">&quot;path/to/your/downloaded_file.txt&quot;</span></span><br><span class="line">err = minioClient.FGetObject(context.Background(), bucketName, objectName, downloadFilePath, minio.GetObjectOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">downloadedFile, err := os.Open(downloadFilePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> downloadedFile.Close()</span><br><span class="line"></span><br><span class="line">downloadHash := sha256.New()</span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(downloadHash, downloadedFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Downloaded file SHA-256 hash: %x\n&quot;</span>, downloadHash.Sum(<span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">if</span> hash.Sum(<span class="literal">nil</span>) == downloadHash.Sum(<span class="literal">nil</span>) &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Data integrity verified successfully.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Data integrity verification failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上传文件时，通过io.TeeReader同时计算文件的SHA-256哈希值。<br>下载文件后，重新计算下载文件的SHA-256哈希值。<br>比较上传和下载文件的哈希值以验证数据的完整性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#minio--&quot;&gt;MinIO介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pvc---persistent-volume-claim-&quot;&gt;PVC概念（Persistent Volume Claim）&lt;/a&gt;&lt;</summary>
      
    
    
    
    
    <category term="分布式系统" scheme="http://gladiouszhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="实习项目" scheme="http://gladiouszhang.github.io/tags/%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记——List, Set, Map</title>
    <link href="http://gladiouszhang.github.io/2024/04/18/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94List-Set-Map/"/>
    <id>http://gladiouszhang.github.io/2024/04/18/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94List-Set-Map/</id>
    <published>2024-04-18T11:47:16.000Z</published>
    <updated>2024-08-11T10:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/04/18/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94List-Set-Map/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5a2mSkFWQeeahOengOeQtA==,size_15,color_FFFFFF,t_70,g_se,x_16-1713407102148-3.png" alt="集合框架图"></p><h1 id="List-包含ArrayList-Vector-LinkedList"><a href="#List-包含ArrayList-Vector-LinkedList" class="headerlink" title="List(包含ArrayList, Vector, LinkedList)"></a>List(包含ArrayList, Vector, LinkedList)</h1><p>ArrayList底层使用数组实现数据存储<br>ArrayList基本等同与Vector，但是Vector线程安全（因此ArrayList更快）<br>ArrayList源码分析：<br>维护一个Object类型的数组elementData，如果使用无参构造器，初始化数组大小为0，第一次添加扩容为10，再次扩容是每次扩容1.5倍。如果使用指定大小的构造器，则直接初始化为指定大小，每次扩容1.5倍。elementData用transient修饰，表示该属性不会被序列化。<br>Vector底层也是elementData数组，多线程操作时使用Vector。无参构造时默认长度为10，满了以后每次增加2倍，如果指定大小，满后则直接扩容两倍（其实可以设置每次增长量，如果没有设置，就默认翻倍）<br>LinkedList底层实现了双向链表和双端队列，没有实现同步，线程不安全。增删较多用LinkedList，改查较多用ArrayList</p><h1 id="Set-包含HashSet-LinkedHashSet"><a href="#Set-包含HashSet-LinkedHashSet" class="headerlink" title="Set(包含HashSet, LinkedHashSet)"></a>Set(包含HashSet, LinkedHashSet)</h1><p>hashset底层是hashmap，hashmap底层是数组+链表+红黑树，hashmap初始化长度为16，数据到一定量(JAVA8中链表长度≥8，table大小≥64)后变成红黑树。如果链表到了8，table没到64，那么table扩容为2倍。此外，table中所有<strong>节点的数量</strong>到threshold(0.75乘以table长度，初始是16*0.75&#x3D;12)时进行扩容，扩容也是扩为2倍。扩容的同时，原有的元素会被重新放置（因为数组大小改变）。</p><p>LinkedHashSet底层是一个LinkedHashMap，其底层维护了一个数组+双向链表，使用hashCode决定在table中的位置，双向链表维护插入顺序，使得元素看起来是按顺序插入的。相当于在HashTable（HashMap）的Node外面套了一层壳（Entry），加上了before和after字段。其目的就是为了维护顺序，并且减小查询开销（可以直接计算hash）。遍历时使用LinkedHashMap的head字段进行遍历。扩容等机制和HashMap相同。</p><h1 id="Map-包含HashMap-LinkedHashMap-Hashtable-Priorities"><a href="#Map-包含HashMap-LinkedHashMap-Hashtable-Priorities" class="headerlink" title="Map(包含HashMap, LinkedHashMap, Hashtable, Priorities)"></a>Map(包含HashMap, LinkedHashMap, Hashtable, Priorities)</h1><p>HashMap在加入相同键时会发生替换，而替换时并不会改变modCount，modCount是一个用于记录HashMap结构修改次数（改变HashMap中映射数量或者修改内部结构）的变量。HashMap是线程不安全的。</p><p>Hashtable底层维护一个table数组，数组存储Hashtable$Entry对象，形成链表。初始化table大小11，threshold为大小乘以0.75(向下取整)。扩容机制:左移一位(乘以二)加一。Hashtable的效率比HashMap低。HashTable的键值都不能为空，是线程安全的</p><p>properties可以读取xx.properties文件，获取文件中的配置(举例:数据库)</p><h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><ul><li>插入单列元素：Collection(List、Set)<ul><li>允许重复：List<ul><li>不用线程安全，效率高：<ul><li>具有大量增删操作：LinkedList</li><li>具有大量改查操作：ArrayList</li></ul></li><li>线程安全，效率低：Vector</li></ul></li><li>不允许重复：Set<ul><li>无序：HashSet（底层使用HashMap）</li><li>排序：TreeSet</li><li>按插入顺序：LinkedHashSet（底层使用LinkedHashMap）</li></ul></li></ul></li><li>插入双列元素：Map<ul><li>无需线程安全：<ul><li>无序：HashMap</li><li>排序：TreeMap</li><li>按插入顺序：LinkedHashMap</li></ul></li><li>线程安全：<ul><li>读取文件：Properties</li><li>其他：Hashtable</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/04/18/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94List-Set-Map/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shado</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://gladiouszhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记——包装类</title>
    <link href="http://gladiouszhang.github.io/2024/04/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://gladiouszhang.github.io/2024/04/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2024-04-13T11:46:10.000Z</published>
    <updated>2024-07-31T11:46:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>装箱： 基本类型-&gt;包装类型。拆箱相反。jdk5及以后自动拆装箱。</p><p>手动装箱需要用到<code>new Integer(n)</code>或者<code>Integer.valueOf(n)</code>，手动拆箱需要<code>integer.intValue()</code>。自动拆装箱可以无视数据类型直接赋值，但底层实际上还是一样的。</p><p>Integer使用自动装箱（或手动装箱的valueOf方法）创建对象时，如果范围在-128-127范围内，返回的对象是同一个，不在范围内时底层new对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;装箱： 基本类型-&amp;gt;包装类型。拆箱相反。jdk5及以后自动拆装箱。&lt;/p&gt;
&lt;p&gt;手动装箱需要用到&lt;code&gt;new Integer(n)&lt;/code&gt;或者&lt;code&gt;Integer.valueOf(n)&lt;/code&gt;，手动拆箱需要&lt;code&gt;integer.intV</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://gladiouszhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记——异常</title>
    <link href="http://gladiouszhang.github.io/2024/04/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/"/>
    <id>http://gladiouszhang.github.io/2024/04/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/</id>
    <published>2024-04-12T11:44:46.000Z</published>
    <updated>2024-07-31T11:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了维护健壮性。<br>Idea捕获异常快捷键ctrl+alt+t。语法try{语句}catch(Exception e){异常处理}<br>异常事件:Error:JVM无法处理的严重问题，如栈溢出，内存不足。Exception:编程错误或偶然因素导致的一般问题。如空指针，文件不存在。Exception分为运行时异常和编译时异常。运行时异常可以暂时不用处理(太多)，编译时异常必须处理(如文件不存在，类不存在)。<br>空指针异常:运行时异常，使用对象对象为空。<br>数学运算异常:例如除以0。<br>数组越界异常<br>类型转换异常:试图把对象强制转化为不是实例的子类。<br>数字格式异常:字符串转化为数字，但是该字符串不满足时。<br>异常处理方式:try-catch-finally:程序员自行处理异常。throws:将异常抛出，由调用者处理。最顶级的调用者是JVM(main)<br>try-catch-finally过程:异常发生时，系统将异常封装为Exception对象e，传递给catch。有没有发生异常都执行finally。故经常将释放资源的代码放在finally。<br>throws机制:层层往上扔。throws是放在方法的后边，如果出错就会throws。<br>finally一定会执行，就算前面有return了，finally也会执行。如果没有catch，那么finally执行完就结束了(因为没有捕捉到错误，错误发生，程序崩溃)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了维护健壮性。&lt;br&gt;Idea捕获异常快捷键ctrl+alt+t。语法try{语句}catch(Exception e){异常处理}&lt;br&gt;异常事件:Error:JVM无法处理的严重问题，如栈溢出，内存不足。Exception:编程错误或偶然因素导致的一般问题。如空指针，</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://gladiouszhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>摄影分享</title>
    <link href="http://gladiouszhang.github.io/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/"/>
    <id>http://gladiouszhang.github.io/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/</id>
    <published>2024-04-11T08:31:03.000Z</published>
    <updated>2024-07-31T16:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075507-01.jpeg" alt="1000075507-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075509-01.jpeg" alt="1000075509-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075511-01.jpeg" alt="1000075511-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075521-01.jpeg" alt="1000075521-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075523-01.jpeg" alt="1000075523-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075539-01.jpeg" alt="1000075539-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075555-01.jpeg" alt="1000075555-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075713-01.jpeg" alt="1000075713-01"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/retouch_2024041017194334.jpg" alt="retouch_2024041017194334"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/retouch_2024041019275679.jpg" alt="retouch_2024041019275679"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/retouch_2024041019301178.jpg" alt="retouch_2024041019301178"></p><p><img src="/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/retouch_2024041019320929.jpg" alt="retouch_2024041019320929"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/04/11/%E6%91%84%E5%BD%B1%E5%88%86%E4%BA%AB/1000075507-01.jpeg&quot; alt=&quot;1000075507-01&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/11/%E6%91%8</summary>
      
    
    
    
    
    <category term="摄影" scheme="http://gladiouszhang.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记——面向对象，枚举类，注解</title>
    <link href="http://gladiouszhang.github.io/2024/04/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%8C%E6%B3%A8%E8%A7%A3/"/>
    <id>http://gladiouszhang.github.io/2024/04/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%8C%E6%B3%A8%E8%A7%A3/</id>
    <published>2024-04-06T08:28:27.000Z</published>
    <updated>2024-07-31T08:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类变量:static。所有的对象共享。jdk7及以前放在静态域，jdk8及以后放在堆。随着类的创建而加载，类的销毁而销毁。<br>类方法:static。直接通过类名调用，不用创建实例。<br>静态方法只能访问静态成员，非静态方法都可以访问。<br>main方法:Public static void main(String［］ args)。Public是为了JVM调用。static是为了调用时不需要创建对象。void代表没有返回值。args接收参数。<br>代码块:又叫初始化块，属于类的成员，类似于方法，将逻辑语句用{}包裹起来。加载类或创建对象时隐式调用。修饰符仅可选static。相当于另外一种形式的构造器。如果多个构造器有相同内容可以抽取出来放在代码块中，实现代码重用。<br>单例设计模式:保证在整个软件周期中某个类只存在一个对象实例，并且只提供一个取得其对象实例的方法。构造器私有化(防止直接new)，类的内部创建对象，向外暴露一个Public static方法getInstance。分为饿汉式和懒汉式。饿汉式是直接创建一个私有静态对象(构造器为私有)，提供一个公共的static方法返回对象。懒汉式是先在类中声明一个Private static的对象，在getInstance的时候判断对象是否为空，如果为空才创建对象。<br>final:修饰类，不能被继承;修饰属性，不能被修改;修饰变量，不能被修改。<br>抽象类:父类方法中含有abstract方法，这个类就是一个抽象类。抽象类不能被实例化。抽象类不一定有abstract方法，但一旦有abstract方法一定是抽象类。abstract只能修饰类和方法。抽象方法不能有主体。抽象类也可以被抽象类继承，子类如果不是抽象类，需要实现抽象类的所有抽象方法。<br>抽象类的最佳时机:模板设计模式。相当于给子类定下来了一些模板。<br>接口interface:更抽象的抽象类，jdk7及以前所有方法都没有方法体，jdk8及以后接口内可以有静态方法，默认方法，可以有方法的具体实现。接口类型可以接受实现了该接口的对象(多态)。接口存在多态传递，即A实现B接口，C继承A，则C耶实现了B接口。<br>内部类:在其他类的内部嵌套的类。类的五大成员:属性，方法，构造器，代码块，内部类。内部类可访问外部类的私有属性。定义在类的局部位置(方法，代码块)的有局部内部类和匿名内部类，定义在成员位置的有成员内部类和静态内部类。匿名内部类相对比较重要，即在new一个类(或接口)的时候定义参数与类体，没有具体的名字:new class(参数列表){类体}。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举就是事先在类里面定义好对象。enum 类名{在最开始初始化枚举对象}</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解:@Override:重写父类方法，@Deprecated:已过时，@SupressWarning:抑制警告。<br>元注解:注解的注解。Retention:注解的作用范围，包括SOURCE(只在源码)，CLASS(保留到CLASS文件中)，RUNTIME(保存到运行时)。Target:注解的作用对象。Documented:注解是否在javadoc体现。Inherited:子类是否继承父类注解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;p&gt;类变量:static。所有的对象共享。jdk7及以前放在静态域，jdk8及以后放在堆。随着类的创建而加载，类的销毁而销毁。&lt;</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://gladiouszhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>mit6.824笔记</title>
    <link href="http://gladiouszhang.github.io/2024/03/31/mit6-824%E7%AC%94%E8%AE%B0/"/>
    <id>http://gladiouszhang.github.io/2024/03/31/mit6-824%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-31T08:20:53.000Z</published>
    <updated>2024-08-01T14:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">环境配置</a></li><li><a href="#lab1">lab1</a><ul><li><a href="#---mrsequentialgo-">阅读<code>mrsequential.go</code></a></li><li><a href="#---wcgo-">阅读<code>wc.go</code></a></li><li><a href="#--">任务</a></li><li><a href="#--">阅读</a><ul><li><a href="#-mrcoordinatorgo-"><code>mrcoordinator.go</code></a></li><li><a href="#-mrworkergo-"><code>mrworker.go</code></a></li><li><a href="#-coordinatorgo-"><code>coordinator.go</code></a></li><li><a href="#-rpcgo-"><code>rpc.go</code></a></li><li><a href="#-workergo-"><code>worker.go</code></a></li></ul></li><li><a href="#--">思路</a></li></ul></li></ul><!-- tocstop --><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>环境：Ubuntu 20.04</p><p>配置go语言环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install golang</span><br></pre></td></tr></table></figure><p>在vscode里面安装go的插件</p><h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p><code>.so</code>文件是go里面的插件。在本lab中<code>mrsequential.go</code>是主程序。每次运行主程序的时候选择一个插件，即具体的map-reduce过程。</p><h2 id="阅读mrsequential-go"><a href="#阅读mrsequential-go" class="headerlink" title="阅读mrsequential.go"></a>阅读<code>mrsequential.go</code></h2><p><code>os.Args</code> 是一个字符串切片，包含了程序运行时的所有命令行参数，包括程序名本身。程序需要至少两个参数：xxx.so 插件文件和至少一个输入文件。</p><p>如果合法，则加载插件中的map和reduce方法。</p><p>创建一个中间输出的键值对切片。</p><p>对于所有输入的文件，将其分别打开并全部读入，调用插件中的map函数，生成中间键值对，并将键值对的内容全部加入先前创建的中间输出切片。</p><p>如果要将一个切片的所有元素追加到另一个切片中，可以使用 <code>...</code> 操作符。这个操作符告诉编译器将切片展开为一个个的元素。如果不使用 <code>...</code>，则会尝试将整个切片作为一个元素添加到目标切片中。</p><p>与真实的<code>MapReduce</code>不同，这里的<code>mrsequential.go</code>将所有的中间数据都存储在一个切片中，而不是被切分成N*M个。</p><p>对key进行排序。</p><p>对于每一个中间输出的键值对，检查有多少个key相同，把相同的key数量统计为j，并将这j个相同key的键值对的value存入一个字符串切片，将这个相同的key和字符串切片传入自定义的reduce方法中，最后键值对结果保存到mr-out-0中。</p><p>具体的<code>loadPlugin</code>函数（即加载map和reduce方法的函数），用Lookup来寻找文件中的方法，返回该方法的引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapf := xmapf.(func(string, string) []mr.KeyValue)</span><br></pre></td></tr></table></figure><p>这行代码通过类型断言将 <code>xmapf</code> 变量转换成具体的函数类型 <code>func(string, string) []mr.KeyValue</code>。这意味着程序预期找到的 <code>&quot;Map&quot;</code> 函数应该接受两个 <code>string</code> 类型的参数，并返回一个 <code>mr.KeyValue</code> 类型的切片。</p><blockquote><p>Lookup返回一个空接口类型 <code>interface&#123;&#125;</code> 。可以理解空接口类型就像java中的object，所有类都继承他，但是具体是啥需要自行解释（断言），是一种多态的体现。如果断言错误就会出现恐慌（panic）。</p></blockquote><h2 id="阅读wc-go"><a href="#阅读wc-go" class="headerlink" title="阅读wc.go"></a>阅读<code>wc.go</code></h2><p>实现了map和reduce方法。map读入文件名和以字符串形式传入的文件内容，实际上并没有用到文件名。</p><p>在map方法中，首先创建了一个判断分隔符的函数，将其作为回调函数来分割文件内容，返回一个个索引和单词组成的切片。遍历切片，将所有的单词用“单词: 1”的键值对存储在切片中。返回切片。</p><p>reduce方法直接返回了values的长度。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>实现一个分布式 MapReduce，它由两个程序（<code>coordinator</code>和<code>worker</code>）组成。只有一个协调程序和一个或多个并行执行的工作程序。在真实系统中，<code>worker</code>会运行在多台不同的机器上，但在本lab中，你将在一台机器上运行所有<code>worker</code>。<code>worker</code>将通过 RPC 与协调程序对话。每个 <code>worker</code> 进程将循环向<code>coordinator</code>请求任务，从一个或多个文件中读取任务输入，执行任务，将任务输出写入一个或多个文件，然后再次向<code>coordinator</code>请求新任务。<code>coordinator</code>应该注意到，如果某个 <code>worker</code> 在合理的时间内（本lab使用 10 秒）没有完成任务，就会将相同的任务交给不同的 <code>worker</code> 。</p><p>提供的代码位于<code>main/mrcoordinator.go</code> 和<code>main/mrworker.go</code>，最后实现的代码放在 <code>mr/coordinator.go</code>, <code>mr/worker.go</code>和 <code>mr/rpc.go</code>。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>首先阅读一下源码。其中<code>main/mrcoordinator.go</code> 和<code>main/mrworker.go</code>是不能修改的，<code>mrcoordinator.go</code>用于调用自己编写的 <code>mr/coordinator.go</code>，<code>mrworker.go</code>用于开启一个worker进程，具体实现在<code>mr/rpc.go</code>。</p><h3 id="mrcoordinator-go"><a href="#mrcoordinator-go" class="headerlink" title="mrcoordinator.go"></a><code>mrcoordinator.go</code></h3><p>调用了<code>mr/coordinator.go</code>，将所有文件名称传入<code>MakeCoordinator</code>方法，同时传入10，代表10个reduce任务。当<code>Done</code>返回true的时候结束。</p><h3 id="mrworker-go"><a href="#mrworker-go" class="headerlink" title="mrworker.go"></a><code>mrworker.go</code></h3><p>加载插件，生成map和reduce方法，传给自己创建的worker。</p><h3 id="coordinator-go"><a href="#coordinator-go" class="headerlink" title="coordinator.go"></a><code>coordinator.go</code></h3><p>创建了一个<code>Coordinator</code>类，主要包含<code>server</code>，<code>Done</code>方法。<code>server</code>方法用于开启一个接受RPC请求的线程。<code>Done</code>方法用于判断工作是否结束。<code>MakeCoordinator</code>函数被<code>mrcoordinator.go</code>调用，返回一个<code>Coordinator&#123;&#125;</code>的实例。</p><h3 id="rpc-go"><a href="#rpc-go" class="headerlink" title="rpc.go"></a><code>rpc.go</code></h3><p>RPC相关的一些定义，自定义时需要首字母大写。包含一个<code>coordinatorSock() </code>函数，用于在<code>/var/tmp/</code>目录下创建一个套接字文件，名为<code>5840-mr-UserId</code>。这个函数并不直接创建，而是返回这样一个路径下命名的字符串。</p><h3 id="worker-go"><a href="#worker-go" class="headerlink" title="worker.go"></a><code>worker.go</code></h3><p>在其中定义了键值对的结构体。</p><p>创建了一个将不同键通过对其哈希值取模分配到N个reduce任务的方法。</p><p>最主要的是<code>main/mrworker.go</code>会调用的Worker方法，传入map和reduce方法，主要是在这里写代码。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先编写coordinator.go，实现rpc和工作的分发。</p><p>在coordinator.go应当事先记录一下有哪些文件，哪些已经完成了，哪些超时了，在worker进行远程过程调用时进行判断，决定发送哪个文件给worker。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span>&#123;</span><br><span class="line">Filename <span class="type">string</span></span><br><span class="line">Status <span class="type">bool</span></span><br><span class="line">Start time.Time</span><br><span class="line">Next *Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task组成的链表</span></span><br><span class="line"><span class="keyword">type</span> TaskList <span class="keyword">struct</span> &#123;</span><br><span class="line">    Head *Task</span><br><span class="line">Tail *Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">tasklist TaskList</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----&quot;&gt;环境配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lab1&quot;&gt;lab1&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#---mrsequentialgo-&quot;&gt;阅读&lt;code&gt;mrsequential</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://gladiouszhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式系统" scheme="http://gladiouszhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
